+++
title = "XV6-2020 LAB10-MMAP"
date = 2025-08-26

[taxonomies]
tags = ["xv6"]

[extra]
comment = true
+++

# 前言
什么是`mmap()`呢？它为什么比传统的 read()/write() 更方便呢？        

好，现在用户要打开一个PDF文件，用户想要读书了，但是书差不多有2000页，他不想在今天读完。     
如果是`read()`/`write()`，虽然可以通过分段读取避免内存浪费，但需要程序员手动维护文件偏移量和缓冲区，实现起来比较繁琐。      

而`mmap()`提供了更优雅的解决方案，它通过内存映射的方式，将文件内容直接映射到进程的虚拟地址空间（VMA分区）。      
当用户昨天读到第255页，今天重新打开时，
系统通过按需加载机制，
只会将实际访问的第255页附近的数据加载到物理内存中，而不是整个文件。    

这种机制特别适合随机访问的场景。        
用户可能跳跃式地阅读不同章节，mmap()的缺页中断机制会自动处理数据的加载和缓存，无需人工干预。      

# 作业要求
我们要实现的`mmap()`接口如下：      
```C
void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);
```
我来说说一下这些参数：
- `addr`：就是用户希望自己的文件被映射到什么位置（地址），测试文件只会使用0，读者们可以只处理0的情况，也就是自动分配地址。        
> 我的方案比较不一样，是这样的：
> - 0：自动分配
> - !0且合法：尝试映射指定地址
> - !0但已占用：自动分配
> - 非法：返回错误        
>
> 这里对非法的定义是，不在VMA范围内的，或是没对齐。

- `length`：用户希望自己的结束地址是`addr`加上多少，可以大于真实的文件的长度。

最后编辑时间：2025/8/26