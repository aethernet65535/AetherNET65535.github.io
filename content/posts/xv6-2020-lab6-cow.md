+++
title = "XV6-2020 LAB6-COW"
date = 2025-06-25

[taxonomies]
tags = ["xv6"]

[extra]
comment = true
+++

## 前言（废话）
这个不算太容易，有个地方困扰了我很久，不过我目前还是没发现为什么就是了，之后可能会去仔细研究（调试？）。        
不过现在的话，我就先整理一些资料给读者们和未来的自己而已。      
我想更多的是整理给未来的自己，毕竟我这垃圾笔记有谁会看呢hhh。       
不过整理给自己也很好就是了，如果屏幕前的读者觉得自己学了但是不理解的话，可以试试写笔记写博客之类的，你要写出你理解的东西，不理解的现在就去学。      
这样的话有助于更好的理解你所学到的，即使之后忘了也没关系，再回来看，努力记住！      

读者们都要加油哦，成为厉害的大人！(๑•̀ㅂ•́)و✧

## 问题
**XV6**现在的`fork()`有什么问题呢？       
现在是这样的，当调用`fork()`时，系统就会复制父进程，然后创建同样多的物理页，全复制给子进程。      
不是映射哦，是完全复制，就像克隆一样呢，完全复制，和我们之前做的那种内核页表映射不同。

这样做有什么问题吗？        
当然有，问题就是用了太多内存了。        
比如我要创建一个子进程，但是其实它只需要查看父进程的东西而已。      
之后我创建了一个进程，叫`foo`，然后我在里面放了很多资料，我需要一个子进程帮我查看资料。     
于是我就创建了一个`bar`子进程，它只需要查看`foo`进程里的数据，然后条件筛选返回给用户就可以了。      
这样的话，是不是其实它做的**写入**操作是很少很少的呢？对！      
那这样也就是说，我们浪费了很多不该浪费的内存，因为两个进程拥有超级多一样的数据，但是却也有双倍的内存大小！      

读者们也觉得这样很不好，对吧？      
所以**XV6**就要我们学会优化这东西，我们要让那些有父子关系的或者后代在一页内有相同数据时，尽可能让它们使用同一个物理页，以此来节省好多内存！（也有可能很少，但是反正这是好事！）

## 思路
所以，我们就需要思考，要怎么优化呢？        
首先我们已经知道了一个东西，就是**物理页**相同的话，就要让它们指向同一个**物理页**，而不是创建多一个。      

但是这样的话，如果某个进程去修改了**那一页**，那么就会影响到那些同样映射着那个**物理页**的进程不是吗？      
我们现在又知道了，如果某个进程要修改的话，就一定不能让它影响其他进程。      
那么应该怎么做，答案就是，当我们知道有某个进程想要修改某个**多进程映射的页**时，就自动创建一个**独立的物理页**给那个某某进程。      

诶，但是，我们要怎么知道进程要对某个**物理页**进行修改，并且及时干涉呢？        
简单，当进程想要修改**页**的时候，它要干什么？      
没错，就是**写入**，进程需要**写入**才可以修改，对吧？      
而且呀，我们上一个**LAB**不就是**LAZYALLOC**吗？**COW**其实也差不多，不过更复杂而已。       

虽然我们知道了可以用**写入**来判断，但是要怎么知道进程要**写入**了呢？每次**写入**都要检查吗？那样对于我们这些初学者就太不方便了（至少我是，读者们可能都是大佬！）。        
所以我们可以这样，当某个进程调用`fork()`的时候，就去除双方（old和new）所有**物理页的写入权限**，这样它们**写入**的时候就会报**15号错误（STORE）**，这个时候我们就可以给它创建一个**独立的物理页**了，然后它就可以更改且不影响其他进程了。

但是呀，当某个进程试图对那些**不可写入**的页写入时，我们也得阻止，加个标识符就行了，就叫...PTE_COW吧！这个很容易记得对吧！ヾ(≧▽≦*)o
