+++
title = "XV6-2020 LAB6-COW"
date = 2025-06-25

[taxonomies]
tags = ["xv6"]

[extra]
comment = true
+++

## 前言（废话）
这个不算太容易，有个地方困扰了我很久，不过我目前还是没发现为什么就是了，之后可能会去仔细研究（调试？）。        
不过现在的话，我就先整理一些资料给读者们和未来的自己而已。      
我想更多的是整理给未来的自己，毕竟我这垃圾笔记有谁会看呢hhh。       
不过整理给自己也很好就是了，如果屏幕前的读者觉得自己学了但是不理解的话，可以试试写笔记写博客之类的，你要写出你理解的东西，不理解的现在就去学。      
这样的话有助于更好的理解你所学到的，即使之后忘了也没关系，再回来看，努力记住！      

读者们都要加油哦，成为厉害的大人！(๑•̀ㅂ•́)و✧

## 问题
**XV6**现在的`fork()`有什么问题呢？       
现在是这样的，当调用`fork()`时，系统就会复制父进程，然后创建同样多的物理页，全复制给子进程。      
不是映射哦，是完全复制，就像克隆一样呢，完全复制，和我们之前做的那种内核页表映射不同。

这样做有什么问题吗？        
当然有，问题就是用了太多内存了。        
比如我要创建一个子进程，但是其实它只需要查看父进程的东西而已。      
之后我创建了一个进程，叫`foo`，然后我在里面放了很多资料，我需要一个子进程帮我查看资料。     
于是我就创建了一个`bar`子进程，它只需要查看`foo`进程里的数据，然后条件筛选返回给用户就可以了。      
这样的话，是不是其实它做的**写入**操作是很少很少的呢？对！      
那这样也就是说，我们浪费了很多不该浪费的内存，因为两个进程拥有超级多一样的数据，但是却也有双倍的内存大小！      

读者们也觉得这样很不好，对吧？      
所以**XV6**就要我们学会优化这东西，我们要让那些有父子关系的或者后代在一页内有相同数据时，尽可能让它们使用同一个物理页，以此来节省好多内存！（也有可能很少，但是反正这是好事！）

## 思路
所以，我们就需要思考，要怎么优化呢？        
首先我们已经知道了一个东西，就是**物理页**相同的话，就要让它们指向同一个**物理页**，而不是创建多一个。      

但是这样的话，如果某个进程去修改了**那一页**，那么就会影响到那些同样映射着那个**物理页**的进程不是吗？      
我们现在又知道了，如果某个进程要修改的话，就一定不能让它影响其他进程。      
那么应该怎么做，答案就是，当我们知道有某个进程想要修改某个**多进程映射的页**时，就自动创建一个**独立的物理页**给那个某某进程。      

诶，但是，我们要怎么知道进程要对某个**物理页**进行修改，并且及时干涉呢？        
简单，当进程想要修改**页**的时候，它要干什么？      
没错，就是**写入**，进程需要**写入**才可以修改，对吧？      
而且呀，我们上一个**LAB**不就是**LAZYALLOC**吗？**COW**其实也差不多，不过更复杂而已。       

虽然我们知道了可以用**写入**来判断，但是要怎么知道进程要**写入**了呢？每次**写入**都要检查吗？那样对于我们这些初学者就太不方便了（至少我是，读者们可能都是大佬！）。        
所以我们可以这样，当某个进程调用`fork()`的时候，就去除双方（old和new）所有**物理页的写入权限**，这样它们**写入**的时候就会报**15号错误（STORE）**，这个时候我们就可以给它创建一个**独立的物理页**了，然后它就可以更改且不影响其他进程了。

但是呀，当某个进程试图对那些**不可写入**的页写入时，我们也得阻止，加个标识符就行了，就叫...PTE_COW吧！这个很容易记得对吧！ヾ(≧▽≦*)o

## implement copy-on-write (hard)
我重复下**XV6**说过的话，就是要求之类的东西。

### 通过条件
只要修改后的内核通过了`cowtest`和`usertests`程序，那就算你通过了此测试。

### 解题思路（提示）
- 修改`uvmcopy()`，使其不再使用`kalloc()`分配物理页，而是将父进程的页都映射到子进程的页，并且记得要消除双方的**PTE_W**。
- 修改`usertrap()`，使其对**15号错误有某种特殊处理**，当**COW**页出现错误时，使用`kalloc()`分配物理页，并将旧页的内容复制到新页，当然也不能忘了添加**PTE_W**权限。
- 确保每个物理页，只有在没有任何进程引用时才释放。添加**引用次数**是一种不错的方法。
使用`kalloc()`分配物理页时，**设置**其**引用次数为1**（注意是设置，尽量别预设引用次数为0，博主预设了，所以在某个地方卡了很久）。
当`uvmcopy()`时，就把**引用次数+1**，相反的，在你的`某某函数()`给物理页独立出来时，也必须对之前映射的物理页的**引用次数-1**。
只有在**引用次数==0**时，才可以释放该物理页。
你可以使用数组来管理**引用次数**，例如`uint16 pgrfc[(PHYSTOP - KERNBASE) / PGSIZE]`。
- 你可以使用**自旋锁**来保护该数组的资源。
- 修改`copyout()`，让其与**页错误**使用相同的处理方案。
- 这和`lazy allocation`那个作业差不多，可以参考。但是别基于那个分支做，要遵守规则，用新分支来做哦。
- 关于`PTE_COW`，可以看看**RISC-V**的一些资料，搜搜**RSW**，为软件保留的PTE位，很有用的哦。

	>再给点额外提示，**SV39**的**PTE位**从**0-8**分别是`V, R, W, X, U, G, A, D, RSW`。哎呀哪个是能存`PTE_COW`的呢，好难猜呀||ヽ(*￣▽￣*)ノミ|Ю

- 如果发生`COW`错误时，内存不足了，就该终止该进程。
- 当进程试图写入不可写入且不是COW的物理页时，那么最简单的方法应该是终止该进程。

	>原因如下：
	>- 内核不该修改或跳过用户的某段指令，这不是内核该做的，而且这一般只会让情况更遭。
	>- 内核可以返回错误信息，但是这是极其复杂的。

	>PS: 你看着可能会觉得我说的有点尖锐，不过我绝对没有要故意尖锐的意思哦，只是提醒而已，读者们千万不要想什么终止进程以外的方案。我是说，可以想，但是最好不要尝试在作业中优化这个东西，很复杂的！！（是大佬的话当我没说(￣▽￣)"））

### 解决方案（实现）