+++
title = "XV6-2020 LAB6-COW"
date = 2025-06-25

[taxonomies]
tags = ["xv6"]

[extra]
comment = true
+++

## 前言（废话）
这个不算太容易，有个地方困扰了我很久，不过我目前还是没发现为什么就是了，之后可能会去仔细研究（调试？）。        
不过现在的话，我就先整理一些资料给读者们和未来的自己而已。      
我想更多的是整理给未来的自己，毕竟我这垃圾笔记有谁会看呢hhh。       
不过整理给自己也很好就是了，如果屏幕前的读者觉得自己学了但是不理解的话，可以试试写笔记写博客之类的，你要写出你理解的东西，不理解的现在就去学。      
这样的话有助于更好的理解你所学到的，即使之后忘了也没关系，再回来看，努力记住！      

读者们都要加油哦，成为厉害的大人！(๑•̀ㅂ•́)و✧

## 问题
**XV6**现在的`fork()`有什么问题呢？       
现在是这样的，当调用`fork()`时，系统就会复制父进程，然后创建同样多的物理页，全复制给子进程。      
不是映射哦，是完全复制，就像克隆一样呢，完全复制，和我们之前做的那种内核页表映射不同。

这样做有什么问题吗？        
当然有，问题就是用了太多内存了。        
比如我要创建一个子进程，但是其实它只需要查看父进程的东西而已。      
之后我创建了一个进程，叫`foo`，然后我在里面放了很多资料，我需要一个子进程帮我查看资料。     
于是我就创建了一个`bar`子进程，它只需要查看`foo`进程里的数据，然后条件筛选返回给用户就可以了。      
这样的话，是不是其实它做的**写入**操作是很少很少的呢？对！      
那这样也就是说，我们浪费了很多不该浪费的内存，因为两个进程拥有超级多一样的数据，但是却也有双倍的内存大小！      

读者们也觉得这样很不好，对吧？      
所以**XV6**就要我们学会优化这东西，我们要让那些有父子关系的或者后代在一页内有相同数据时，尽可能让它们使用同一个物理页，以此来节省好多内存！（也有可能很少，但是反正这是好事！）

## 思路
所以，我们就需要思考，要怎么优化呢？        
首先我们已经知道了一个东西，就是**物理页**相同的话，就要让它们指向同一个**物理页**，而不是创建多一个。      

但是这样的话，如果某个进程去修改了**那一页**，那么就会影响到那些同样映射着那个**物理页**的进程不是吗？      
我们现在又知道了，如果某个进程要修改的话，就一定不能让它影响其他进程。      
那么应该怎么做，答案就是，当我们知道有某个进程想要修改某个**多进程映射的页**时，就自动创建一个**独立的物理页**给那个某某进程。      

诶，但是，我们要怎么知道进程要对某个**物理页**进行修改，并且及时干涉呢？        
简单，当进程想要修改**页**的时候，它要干什么？      
没错，就是**写入**，进程需要**写入**才可以修改，对吧？      
而且呀，我们上一个**LAB**不就是**LAZYALLOC**吗？**COW**其实也差不多，不过更复杂而已。       

虽然我们知道了可以用**写入**来判断，但是要怎么知道进程要**写入**了呢？每次**写入**都要检查吗？那样对于我们这些初学者就太不方便了（至少我是，读者们可能都是大佬！）。        
所以我们可以这样，当某个进程调用`fork()`的时候，就去除双方（old和new）所有**物理页的写入权限**，这样它们**写入**的时候就会报**15号错误（STORE）**，这个时候我们就可以给它创建一个**独立的物理页**了，然后它就可以更改且不影响其他进程了。

但是呀，当某个进程试图对那些**不可写入**的页写入时，我们也得阻止，加个标识符就行了，就叫...PTE_COW吧！这个很容易记得对吧！ヾ(≧▽≦*)o

## implement copy-on-write (hard)
我重复下**XV6**说过的话，就是要求之类的东西。

### 通过条件
只要修改后的内核通过了`cowtest`和`usertests`程序，那就算你通过了此测试。

### 解题思路（提示）
- 修改`uvmcopy()`，使其不再使用`kalloc()`分配物理页，而是将父进程的页都映射到子进程的页，并且记得要消除双方的**PTE_W**。
- 修改`usertrap()`，使其对**15号错误有某种特殊处理**，当**COW**页出现错误时，使用`kalloc()`分配物理页，并将旧页的内容复制到新页，当然也不能忘了添加**PTE_W**权限。
- 确保每个物理页，只有在没有任何进程引用时才释放。添加**引用次数**是一种不错的方法。
使用`kalloc()`分配物理页时，**设置**其**引用次数为1**（注意是设置，尽量别预设引用次数为0，博主预设了，所以在某个地方卡了很久）。
当`uvmcopy()`时，就把**引用次数+1**，相反的，在你的`某某函数()`给物理页独立出来时，也必须对之前映射的物理页的**引用次数-1**。
只有在**引用次数==0**时，才可以释放该物理页。
你可以使用数组来管理**引用次数**，例如`uint16 pgrfc[(PHYSTOP - KERNBASE) / PGSIZE]`。
- 你可以使用**自旋锁**来保护该数组的资源。
- 修改`copyout()`，让其与**页错误**使用相同的处理方案。
- 这和`lazy allocation`那个作业差不多，可以参考。但是别基于那个分支做，要遵守规则，用新分支来做哦。
- 关于`PTE_COW`，可以看看**RISC-V**的一些资料，搜搜**RSW**，为软件保留的PTE位，很有用的哦。

	>再给点额外提示，**SV39**的**PTE位**从**0-8**分别是`V, R, W, X, U, G, A, D, RSW`。哎呀哪个是能存`PTE_COW`的呢，好难猜呀||ヽ(*￣▽￣*)ノミ|Ю

- 如果发生`COW`错误时，内存不足了，就该终止该进程。
- 当进程试图写入不可写入且不是COW的物理页时，那么最简单的方法应该是终止该进程。

	>原因如下：
	>- 内核不该修改或跳过用户的某段指令，这不是内核该做的，而且这一般只会让情况更遭。
	>- 内核可以返回错误信息，但是这是极其复杂的。

	>PS: 你看着可能会觉得我说的有点尖锐，不过我绝对没有要故意尖锐的意思哦，只是提醒而已，读者们千万不要想什么终止进程以外的方案。我是说，可以想，但是最好不要尝试在作业中优化这个东西，很复杂的！！（是大佬的话当我没说(￣▽￣)"））

### 解决方案（实现）
首先我们需要先完成两个重要的东西，**引用次数的数组**以及保护其的**自旋锁**（SPINLOCK）。		

#### 引用次数的数组
我们先来清除一下，我们需要有多少个地方需要存我们的引用次数呢？大概就是所有常用页表都需要，对吧？		
所以我们就做简单的，只要做`KERNBASE`到`PHYSTOP`这段距离的就行了，我们不弄其他的，这样更简单对吧？		

那么我们就来创建一个数组：`kalloc.c`		
```C
static uint16 pgrfc[(PHYSTOP - KERNBASE) / PGSIZE];
```

顺便做一下一个好用的索引，这个用的有点频繁，所以就做了个，你要自己打也行：
```C
#define index_rfc(pa) ((pa - KERNBASE) >> 12) // pa要删也可以，主要是我调试时会用到
```

#### 自旋锁
其实我们可以从代码里看到大概是怎么做自旋锁的，很简单，看一眼就会了。		

首先先声明一下这个锁：		
```C
struct spinlock rfc_lock;
```

之后，就直接创建就行了，那个字符串要写引用次数的数组变量名：
```C
void
kinit()
{
  initlock(&kmem.lock, "kmem");
  initlock(&rfc_lock, "pgrfc"); // 这行是新增的
  freerange(end, (void*)PHYSTOP);
}
```

#### 改变引用次数
我用了三个函数来解决这些问题，说实话，你真想的话，一个函数都不写也没问题，不过你可以考虑优化我的方案，我的肯定不是最好的。

首先，第一个是自增函数（要说是自减也行）：
```C
int
add_pgrfc(uint64 pa, int n)
{
  // 这个可以说基本触发不了，内核代码都是自己写的，能报错就有鬼了
  // 不过以防万一，加一下，安全检查总归不是坏事
  if((int)pgrfc[index_rfc(pa)] + n < 0 ||
     (int)pgrfc[index_rfc(pa)] + n > 65535){
    panic("set_pgrfc: too big or too small");
    return -1;
  }

  pgrfc[index_rfc(pa)] += n;
  return 0;
}
```

其次是设置函数，完全根据用户的输入来决定该物理页的引用次数：
```C
void
set_pgrfc(uint64 pa, int n)
{
  // 充满血与泪的一行	
  pgrfc[index_rfc(pa)] = n;
}
```

最后就是获取函数，只是返回该物理页的引用次数而已：
```C
uint16
get_pgrfc(uint64 pa)
{
  return pgrfc[index_rfc(pa)];
}
```

#### 释放与初始化
在`kalloc.c/kfree`里，我们得添加一个新东西，就是禁止引用次数非0的物理页被释放，我们要做的仅仅只是对引用次数为大于1的物理页，将其的引用次数-1后再检查：
```C
if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
  panic("kfree");

acquire(&rfc_lock); // 开锁，现在除了我，没有人可以碰引用次数的数组了！
uint16 rfc = get_pgrfc((uint64)pa);
if(rfc > 1){
  add_pgrfc((uint64)pa, -1);
  release(&rfc_lock); // 好，现在谁都可以碰了
  return;
}
release(&rfc_lock); // 一样，谁都可以碰了
```

之后，我们要确保`kalloc.c/kalloc`所分配的物理页，引用次数绝对为1，所以要直接设置：
```C
if(r){
    memset((char*)r, 5, PGSIZE); // fill with junk
    set_pgrfc((uint64)r, 1); // 这里一定得用set，你可能觉得add也一样
							 // 但是不要默认所有进来freelist的物理页引用次数都为0
							 // 博主可以说大部分时间都卡在这里了
							 // 如果你不愿相信的话，可以试试自己printf所有引用次数，看看是不是都为0
  }
  return (void*)r;
```

#### COW & FORK