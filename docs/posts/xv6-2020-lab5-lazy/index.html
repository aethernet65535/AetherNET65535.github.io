<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://aethernet65535.github.io name=base><title>
            
                XV6-2020 LAB5-LAZY
            
        </title><meta content="XV6-2020 LAB5-LAZY" property=og:title><meta content="This is an example description" property=og:description><meta content="This is an example description" name=description><link href=/icon/favicon.png rel=icon type=image/png><link href=https://aethernet65535.github.io/fonts.css rel=stylesheet><script src=https://aethernet65535.github.io/js/codeblock.js></script><script src=https://aethernet65535.github.io/js/toc.js></script><script src=https://aethernet65535.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link href=https://aethernet65535.github.io/atom.xml rel=alternate title=aethernet-blog type=application/atom+xml><link href=https://aethernet65535.github.io/theme/light.css rel=stylesheet><link href=https://aethernet65535.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://aethernet65535.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://aethernet65535.github.io/main.css media=screen rel=stylesheet><script src="https://aethernet65535.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://aethernet65535.github.io>aethernet-blog</a><div class=socials><a class=social href=https://twitter.com/not_matthias rel=me> <img alt=twitter src=https://aethernet65535.github.io/icons/social/twitter.svg> </a><a class=social href=https://github.com/not-matthias/ rel=me> <img alt=github src=https://aethernet65535.github.io/icons/social/github.svg> </a></div></div><nav><a href=https://aethernet65535.github.io/posts style=margin-left:.25em>/posts</a><a href=https://aethernet65535.github.io/projects style=margin-left:.25em>/projects</a><a href=https://aethernet65535.github.io/about style=margin-left:.25em>/about</a><a href=https://aethernet65535.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://aethernet65535.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://aethernet65535.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://aethernet65535.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>XV6-2020 LAB5-LAZY<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2025-06-21</time> :: 1867 Words <span class=tags-label>:: Tags:</span><span class=tags> <a class=post-tag href=https://aethernet65535.github.io/tags/xv6/>xv6</a> </span></div></div><div class=toc-container><h1 class=toc-title>Table of Contents</h1><ul class=toc-list><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab5-lazy/#qian-yan>前言</a> <ul><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab5-lazy/#shen-me-shi-lazy-allocationduo-xing-fen-pei>什么是 Lazy Allocation惰性分配 ？</a></ul><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab5-lazy/#eliminate-allocation-from-sbrk-easy>eliminate allocation from sbrk() (easy)</a> <ul><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab5-lazy/#yuan-dai-ma>原代码</a></li><ul><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab5-lazy/#ng-wei-shen-me-szshi-xin-nei-cun-de-qi-shi-di-zhi-ni-ta-bu-shi-jiu-nei-cun-de-jie-wei-di-zhi-ma>嗯？为什么sz是新内存的起始地址呢？它不是旧内存的结尾地址吗？</a></ul><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab5-lazy/#shan-chu-growproc>删除growproc</a><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab5-lazy/#xiu-gai-jin-cheng-de-szzhi>修改进程的sz值</a><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab5-lazy/#shi-fang-nei-cun-ti-qian-zhun-bei>释放内存（提前准备）</a><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab5-lazy/#yun-xing-jie-guo>运行结果</a></ul><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab5-lazy/#lazy-allocation-moderate>lazy allocation (moderate)</a> <ul><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab5-lazy/#yao-qiu>要求</a></li><ul><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab5-lazy/#ti-shi>提示</a></ul><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab5-lazy/#que-ye-de-zheng-que-chu-li-fang-fa>缺页的正确处理方法</a><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab5-lazy/#fen-pei-nei-cun>分配内存</a><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab5-lazy/#tiao-guo-bu-fen-jian-cha>跳过部分检查</a></ul><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab5-lazy/#lazytests-and-usertests-moderate>lazytests and usertests (moderate)</a> <ul><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab5-lazy/#ti-shi-1>提示</a><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab5-lazy/#xi-tong-diao-yong-diao-zheng>系统调用调整</a></ul><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab5-lazy/#wan-jie-sa-hua>完结撒花</a></ul></div><section class=body><h2 id=qian-yan><a aria-label="Anchor link for: qian-yan" class=zola-anchor href=#qian-yan>前言</a></h2><p>这个LAB的平均难度和LAB4（TRAPS）差不多，就是稍微有点难。不过我们可以通过看Hints来有个大致上的思路。<h3 id=shen-me-shi-lazy-allocationduo-xing-fen-pei><a aria-label="Anchor link for: shen-me-shi-lazy-allocationduo-xing-fen-pei" class=zola-anchor href=#shen-me-shi-lazy-allocationduo-xing-fen-pei>什么是 <strong>Lazy Allocation惰性分配</strong> ？</a></h3><p>Lazy Allocation的功能和它的名字有些像，就是不到最后他都不做，拖延症老严重了呢。(⁠•⁠ ⁠▽⁠ ⁠•⁠;⁠)<p>但是呢，在内存分配，有一点点的拖延症并不是坏事，只要做好工作就是好事，不要让程序和用户察觉到就可以了。<p>重点来了，Lazy和XV6现在的内存分配方案有什么不同？（我们先不说释放内存）<ul><li><strong>XV6：</strong> Foo进程想要内存，所以他调用<code>sbrk</code>，而<code>sbrk</code>则会调用<code>growproc</code>，它会给该进程的<code>sz</code>字段增值，然后直接给Foo 进程<code>kalloc()</code>，就是直接把页表借给他用。<li><strong>Lazy：</strong> Foo进程调用<code>sbrk</code>，<code>sbrk</code>就会给进程<code>sz</code>增值，但是不给他<code>kalloc()</code>，因为他知道进程还没用到，所以<code>sbrk</code>就表示不急。</ul><p>之后，当Foo进程开始运作时，他就会告诉计算机说“我要对<code>0x65535</code>写入信息”，然后计算机就开始计算“这个进程中的<code>0x65535</code>真正指向哪里呢？”，但是计算机会发现这个虚拟地址是无效的，并把这个无效虚拟地址写入<code>stval</code>寄存器，然后就没然后了，不过XV6倒是会处理，XV6的处理方案是：报错<h2 id=eliminate-allocation-from-sbrk-easy><a aria-label="Anchor link for: eliminate-allocation-from-sbrk-easy" class=zola-anchor href=#eliminate-allocation-from-sbrk-easy>eliminate allocation from sbrk() (easy)</a></h2><p>这个确实没骗人，就是<code>easy</code>难度。我们只要搞破坏就行了，不过因为之后的作业也会用到这个系统调用，所以我们得精心的“搞破坏” ٩(｡・ω・｡)و<p>首先呢，XV6要我们做什么？<ol><li>删除<code>sbrk</code>对<code>growproc</code>的调用<li>只修改进程的<code>sz</code>值（sz + n）</ol><h3 id=yuan-dai-ma><a aria-label="Anchor link for: yuan-dai-ma" class=zola-anchor href=#yuan-dai-ma>原代码</a></h3><p>首先我们先看原代码，然后才开始思考我们要做的事情。 <code>kernel/sysproc.c</code>：<pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span>uint64
</span><span style=color:#f29718>sys_sbrk</span><span>(</span><span style=color:#fa6e32>void</span><span>)
</span><span>{
</span><span>  </span><span style=color:#fa6e32>int</span><span> addr</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>int</span><span> n</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#fa6e32>if</span><span>(</span><span style=color:#f29718>argint</span><span>(</span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>n) </span><span style=color:#ed9366>< </span><span style=color:#ff8f40>0</span><span>)
</span><span>    </span><span style=color:#fa6e32>return </span><span style=color:#ed9366>-</span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>;
</span><span>  addr </span><span style=color:#ed9366>= </span><span style=color:#f29718>myproc</span><span>()</span><span style=color:#ed9366>-></span><span>sz</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>if</span><span>(</span><span style=color:#f29718>growproc</span><span>(n) </span><span style=color:#ed9366>< </span><span style=color:#ff8f40>0</span><span>)
</span><span>    </span><span style=color:#fa6e32>return </span><span style=color:#ed9366>-</span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>return</span><span> addr</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>这代码实现了以下操作：<ol><li>获取用户想要被分配/释放的内存字节量<li>获取当前进程的<code>sz</code>值<li>调用<code>growproc</code>，视情况分配/释放内存<li>返回当前进程的<code>sz</code>值，即新内存的起始地址</ol><h4 id=ng-wei-shen-me-szshi-xin-nei-cun-de-qi-shi-di-zhi-ni-ta-bu-shi-jiu-nei-cun-de-jie-wei-di-zhi-ma><a aria-label="Anchor link for: ng-wei-shen-me-szshi-xin-nei-cun-de-qi-shi-di-zhi-ni-ta-bu-shi-jiu-nei-cun-de-jie-wei-di-zhi-ma" class=zola-anchor href=#ng-wei-shen-me-szshi-xin-nei-cun-de-qi-shi-di-zhi-ni-ta-bu-shi-jiu-nei-cun-de-jie-wei-di-zhi-ma>嗯？为什么<code>sz</code>是新内存的起始地址呢？它不是旧内存的结尾地址吗？</a></h4><p>众所周知，编程有两大难题，其中一个是差一错误： 好，首先我们先忽略内存对齐。<p>如果我们有一个进程，他的<code>sz = 1</code>，那么它能用什么虚拟地址呢？<br> 你可能会觉得是<code>0x01</code>，这不是正确答案。<br> 仔细想一下，如果<code>sz = 0</code>呢？它应该可以使用<code>0x00</code>吗？<br> 肯定是不行的，<code>0</code>应该是不能使用任何内存，对吧？<p>所以<code>sz</code> == <code>可用地址的结束地址 + 1</code>。<br> ヾ(^▽^*)))<h3 id=shan-chu-growproc><a aria-label="Anchor link for: shan-chu-growproc" class=zola-anchor href=#shan-chu-growproc>删除<code>growproc</code></a></h3><p>现在我们先把对<code>growproc</code>给删了，现在代码变成这样：<pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span>uint64
</span><span style=color:#f29718>sys_sbrk</span><span>(</span><span style=color:#fa6e32>void</span><span>)
</span><span>{
</span><span>  </span><span style=color:#fa6e32>int</span><span> addr</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>int</span><span> n</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#fa6e32>if</span><span>(</span><span style=color:#f29718>argint</span><span>(</span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>n) </span><span style=color:#ed9366>< </span><span style=color:#ff8f40>0</span><span>)
</span><span>    </span><span style=color:#fa6e32>return </span><span style=color:#ed9366>-</span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>;
</span><span>  addr </span><span style=color:#ed9366>= </span><span style=color:#f29718>myproc</span><span>()</span><span style=color:#ed9366>-></span><span>sz</span><span style=color:#61676ccc>;
</span><span>  
</span><span>  </span><span style=color:#fa6e32>return</span><span> addr</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h3 id=xiu-gai-jin-cheng-de-szzhi><a aria-label="Anchor link for: xiu-gai-jin-cheng-de-szzhi" class=zola-anchor href=#xiu-gai-jin-cheng-de-szzhi>修改进程的<code>sz</code>值</a></h3><p>然后别忘了这步，这步很重要呀！！<pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span>uint64
</span><span style=color:#f29718>sys_sbrk</span><span>(</span><span style=color:#fa6e32>void</span><span>)
</span><span>{
</span><span>  </span><span style=color:#fa6e32>int</span><span> addr</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>int</span><span> n</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#fa6e32>if</span><span>(</span><span style=color:#f29718>argint</span><span>(</span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>n) </span><span style=color:#ed9366>< </span><span style=color:#ff8f40>0</span><span>)
</span><span>    </span><span style=color:#fa6e32>return </span><span style=color:#ed9366>-</span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#fa6e32>struct</span><span> proc </span><span style=color:#ed9366>*</span><span>p </span><span style=color:#ed9366>= </span><span style=color:#f29718>myproc</span><span>()</span><span style=color:#61676ccc>;
</span><span>  addr </span><span style=color:#ed9366>=</span><span> p</span><span style=color:#ed9366>-></span><span>sz</span><span style=color:#61676ccc>;
</span><span>
</span><span>  p</span><span style=color:#ed9366>-></span><span>sz </span><span style=color:#ed9366>+=</span><span> n</span><span style=color:#61676ccc>;
</span><span>  
</span><span>  </span><span style=color:#fa6e32>return</span><span> addr</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h3 id=shi-fang-nei-cun-ti-qian-zhun-bei><a aria-label="Anchor link for: shi-fang-nei-cun-ti-qian-zhun-bei" class=zola-anchor href=#shi-fang-nei-cun-ti-qian-zhun-bei>释放内存（提前准备）</a></h3><p>这个我不知道要怎么解释，反正就是，你之后肯定会出BUG的，如果你这样写的话，所以如果你怕你以后出BUG的话，就可以先抄成这样，如果想要自己解决BUG的话，可以跳过。<pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span>uint64
</span><span style=color:#f29718>sys_sbrk</span><span>(</span><span style=color:#fa6e32>void</span><span>)
</span><span>{
</span><span>  </span><span style=color:#fa6e32>int</span><span> addr</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>int</span><span> n</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#fa6e32>if</span><span>(</span><span style=color:#f29718>argint</span><span>(</span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>&</span><span>n) </span><span style=color:#ed9366>< </span><span style=color:#ff8f40>0</span><span>)
</span><span>    </span><span style=color:#fa6e32>return </span><span style=color:#ed9366>-</span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#fa6e32>struct</span><span> proc </span><span style=color:#ed9366>*</span><span>p </span><span style=color:#ed9366>= </span><span style=color:#f29718>myproc</span><span>()</span><span style=color:#61676ccc>;
</span><span>  addr </span><span style=color:#ed9366>=</span><span> p</span><span style=color:#ed9366>-></span><span>sz</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#fa6e32>if</span><span>(n </span><span style=color:#ed9366>< </span><span style=color:#ff8f40>0</span><span>){
</span><span>    </span><span style=color:#f29718>uvmdealloc</span><span>(p</span><span style=color:#ed9366>-></span><span>pagetable</span><span style=color:#61676ccc>,</span><span> p</span><span style=color:#ed9366>-></span><span>sz</span><span style=color:#61676ccc>,</span><span> p</span><span style=color:#ed9366>-></span><span>sz</span><span style=color:#ed9366>+</span><span>n)</span><span style=color:#61676ccc>;
</span><span>  }
</span><span>
</span><span>  p</span><span style=color:#ed9366>-></span><span>sz </span><span style=color:#ed9366>+=</span><span> n</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#fa6e32>return</span><span> addr</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h3 id=yun-xing-jie-guo><a aria-label="Anchor link for: yun-xing-jie-guo" class=zola-anchor href=#yun-xing-jie-guo>运行结果</a></h3><pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span>init</span><span style=color:#ed9366>:</span><span> starting sh
</span><span>$ echo hi
</span><span style=color:#f29718>usertrap</span><span>()</span><span style=color:#ed9366>:</span><span> unexpected scause </span><span style=color:#ff8f40>0x000000000000000f</span><span> pid</span><span style=color:#ed9366>=</span><span style=color:#ff8f40>3
</span><span>            sepc</span><span style=color:#ed9366>=</span><span style=color:#ff8f40>0x0000000000001258</span><span> stval</span><span style=color:#ed9366>=</span><span style=color:#ff8f40>0x0000000000004008
</span><span>va</span><span style=color:#ed9366>=</span><span style=color:#ff8f40>0x0000000000004000</span><span> pte</span><span style=color:#ed9366>=</span><span style=color:#ff8f40>0x0000000000000000
</span><span>panic</span><span style=color:#ed9366>:</span><span> uvmunmap</span><span style=color:#ed9366>:</span><span> not mapped
</span></code></pre><p>运行结果可能会是这样，不用太过担心，这是应该的，我们不必太过在意这个报错，直接开始下一个作业就行了！<h2 id=lazy-allocation-moderate><a aria-label="Anchor link for: lazy-allocation-moderate" class=zola-anchor href=#lazy-allocation-moderate>lazy allocation (moderate)</a></h2><p>这个小作业很好玩的，而且也很简单，就是跟着hints走而已。<h3 id=yao-qiu><a aria-label="Anchor link for: yao-qiu" class=zola-anchor href=#yao-qiu>要求</a></h3><p>首先，我们要做什么呢？<br> 刚刚报错了对吧？所以我们现在要做的就是，不让<code>sbrk</code>直接或间接调用<code>growproc</code>，但是要让他不会报错，并且可以正确的执行<code>echo hi</code><h4 id=ti-shi><a aria-label="Anchor link for: ti-shi" class=zola-anchor href=#ti-shi>提示</a></h4><ul><li>此类错误发生时，会修改<code>scause</code>寄存器，如果是<code>13</code>那就是load page fault，<code>15</code>就是store/AMO page fault<li><code>stval</code>会记录计算机试图访问什么虚拟地址时失效了<li>你可以参考<code>uvmalloc</code>的代码，核心是<code>kalloc()</code>+<code>mappages()</code><li>使用<code>PGROUNDDOWN</code>宏对齐到该虚拟地址4KB内的起始地址，简称向下取整<li><code>uvmunmap</code>可能会导致kernel panic（你可以直接跳过某些检查）</ul><h3 id=que-ye-de-zheng-que-chu-li-fang-fa><a aria-label="Anchor link for: que-ye-de-zheng-que-chu-li-fang-fa" class=zola-anchor href=#que-ye-de-zheng-que-chu-li-fang-fa>缺页的正确处理方法</a></h3><p>现在XV6的缺页处理是报错，所以呢，我们得改成，缺页了就尝试给它分页，当然，它得是合法的才行。<br> 我们得保证只有在堆（HEAP）范围内的内存使用LAZY ALLOCATION，而不是整个XV6都用，毕竟<code>sbrk</code>本来就是只给堆用的。<p>我们先看看，当触发PAGE FAULT时，XV6会在哪里报错？ 我们看看<code>kernel/trap.c</code>的<code>usertrap</code>函数：<pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span style=color:#f51818>} </span><span style=color:#fa6e32>else if</span><span>((which_dev </span><span style=color:#ed9366>= </span><span style=color:#f29718>devintr</span><span>()) </span><span style=color:#ed9366>!= </span><span style=color:#ff8f40>0</span><span>){  </span><span style=color:#abb0b6;font-style:italic>// 2 是计时器中断，1 是硬件中断，0 是未识别（就是没中断，不是软件中断）
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ok
</span><span>  } </span><span style=color:#fa6e32>else </span><span>{ </span><span style=color:#abb0b6;font-style:italic>// 就是我们看到的的那个报错
</span><span>    </span><span style=color:#f07171>printf</span><span>(</span><span style=color:#86b300>"usertrap(): unexpected scause </span><span style=color:#ff8f40>%p</span><span style=color:#86b300> pid=</span><span style=color:#ff8f40>%d</span><span style=color:#4cbf99>\n</span><span style=color:#86b300>"</span><span style=color:#61676ccc>, </span><span style=color:#f29718>r_scause</span><span>()</span><span style=color:#61676ccc>,</span><span> p</span><span style=color:#ed9366>-></span><span>pid)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>printf</span><span>(</span><span style=color:#86b300>"            sepc=</span><span style=color:#ff8f40>%p</span><span style=color:#86b300> stval=</span><span style=color:#ff8f40>%p</span><span style=color:#4cbf99>\n</span><span style=color:#86b300>"</span><span style=color:#61676ccc>, </span><span style=color:#f29718>r_sepc</span><span>()</span><span style=color:#61676ccc>, </span><span style=color:#f29718>r_stval</span><span>())</span><span style=color:#61676ccc>;
</span><span>    p</span><span style=color:#ed9366>-></span><span>killed </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>;
</span><span>  }
</span></code></pre><p>现在，我们来做新的处理方法，但是报错可以保留，万一真的错了呢。<pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span style=color:#f51818>} </span><span style=color:#fa6e32>else if</span><span>((which_dev </span><span style=color:#ed9366>= </span><span style=color:#f29718>devintr</span><span>()) </span><span style=color:#ed9366>!= </span><span style=color:#ff8f40>0</span><span>){
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// ok
</span><span>
</span><span>  </span><span style=color:#abb0b6;font-style:italic>// 如果scause存储的是13/15
</span><span>  } </span><span style=color:#fa6e32>else if </span><span>(</span><span style=color:#f29718>r_scause</span><span>() </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>13 </span><span style=color:#ed9366>|| </span><span style=color:#f29718>r_scause</span><span>() </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>15</span><span>){
</span><span>    uint64 stval </span><span style=color:#ed9366>= </span><span style=color:#f29718>r_stval</span><span>()</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// 读取无效虚拟地址
</span><span>    </span><span style=color:#fa6e32>if</span><span>(</span><span style=color:#f29718>lazyalloc</span><span>(stval</span><span style=color:#61676ccc>,</span><span> p) </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>0</span><span>) </span><span style=color:#abb0b6;font-style:italic>// 尝试分配内存
</span><span>      p</span><span style=color:#ed9366>-></span><span>killed </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>;
</span><span>  } </span><span style=color:#fa6e32>else </span><span>{
</span><span>    </span><span style=color:#f07171>printf</span><span>(</span><span style=color:#86b300>"usertrap(): unexpected scause </span><span style=color:#ff8f40>%p</span><span style=color:#86b300> pid=</span><span style=color:#ff8f40>%d</span><span style=color:#4cbf99>\n</span><span style=color:#86b300>"</span><span style=color:#61676ccc>, </span><span style=color:#f29718>r_scause</span><span>()</span><span style=color:#61676ccc>,</span><span> p</span><span style=color:#ed9366>-></span><span>pid)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f07171>printf</span><span>(</span><span style=color:#86b300>"            sepc=</span><span style=color:#ff8f40>%p</span><span style=color:#86b300> stval=</span><span style=color:#ff8f40>%p</span><span style=color:#4cbf99>\n</span><span style=color:#86b300>"</span><span style=color:#61676ccc>, </span><span style=color:#f29718>r_sepc</span><span>()</span><span style=color:#61676ccc>, </span><span style=color:#f29718>r_stval</span><span>())</span><span style=color:#61676ccc>;
</span><span>    p</span><span style=color:#ed9366>-></span><span>killed </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>;
</span><span>  }
</span></code></pre><h3 id=fen-pei-nei-cun><a aria-label="Anchor link for: fen-pei-nei-cun" class=zola-anchor href=#fen-pei-nei-cun>分配内存</a></h3><p>这个你可以选择不封装，当然也可以选择封装，我的建议当然是封装起来，毕竟这函数可以让不少地方调用。<pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span>uint64
</span><span style=color:#f29718>lazyalloc</span><span>(uint64 </span><span style=color:#ff8f40>stval</span><span style=color:#61676ccc>, </span><span style=color:#fa6e32>struct</span><span> proc </span><span style=color:#ed9366>*</span><span style=color:#ff8f40>p</span><span>)
</span><span>{
</span><span>  uint64 va </span><span style=color:#ed9366>= </span><span style=color:#f29718>PGROUNDDOWN</span><span>(stval)</span><span style=color:#61676ccc>;
</span><span>  
</span><span>  </span><span style=color:#fa6e32>if</span><span>(stval </span><span style=color:#ed9366>>=</span><span> p</span><span style=color:#ed9366>-></span><span>sz </span><span style=color:#ed9366>||</span><span> stval </span><span style=color:#ed9366><= </span><span style=color:#f29718>PGROUNDDOWN</span><span>(p</span><span style=color:#ed9366>-></span><span>trapframe</span><span style=color:#ed9366>-></span><span>sp))
</span><span>    </span><span style=color:#fa6e32>return </span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#fa6e32>char </span><span style=color:#ed9366>*</span><span>mem </span><span style=color:#ed9366>= </span><span style=color:#f29718>kalloc</span><span>()</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>if</span><span>(mem </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>0</span><span>){
</span><span>    </span><span style=color:#fa6e32>return </span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>;
</span><span>  }
</span><span>
</span><span>  </span><span style=color:#f07171>memset</span><span>(mem</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>,</span><span> PGSIZE)</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>if</span><span>(</span><span style=color:#f29718>mappages</span><span>(p</span><span style=color:#ed9366>-></span><span>pagetable</span><span style=color:#61676ccc>,</span><span> va</span><span style=color:#61676ccc>,</span><span> PGSIZE</span><span style=color:#61676ccc>, </span><span>(uint64)mem</span><span style=color:#61676ccc>,</span><span> PTE_W</span><span style=color:#ed9366>|</span><span>PTE_X</span><span style=color:#ed9366>|</span><span>PTE_R</span><span style=color:#ed9366>|</span><span>PTE_U) </span><span style=color:#ed9366>!= </span><span style=color:#ff8f40>0</span><span>){
</span><span>    </span><span style=color:#f29718>kfree</span><span>(mem)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>return </span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>;
</span><span>  }
</span><span>
</span><span>  </span><span style=color:#fa6e32>return </span><span>(uint64)mem</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>这个代码的作用是：<br> 对<strong>无效虚拟地址</strong>向下取整，然后检查是否大于进程可以拥有的虚拟地址，再检查是否小于堆的底部<br> （堆的底部是栈，栈只有一页，PGROUNDDOWN(sp) == 栈的底部）。<br> 当<strong>此虚拟地址</strong>不处于该范围内，则必须将其终止。<br> 当<strong>此虚拟地址</strong>处于该范围内，系统将会为其分配/添加<strong>一页</strong>。<p>注：XV6的栈是低地址，堆是高地址<br> <code>kernel/memlayout.h</code><pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span style=color:#abb0b6;font-style:italic>// User memory layout.
</span><span style=color:#abb0b6;font-style:italic>// Address zero first:
</span><span style=color:#abb0b6;font-style:italic>//   text
</span><span style=color:#abb0b6;font-style:italic>//   original data and bss
</span><span style=color:#abb0b6;font-style:italic>//   fixed-size stack
</span><span style=color:#abb0b6;font-style:italic>//   expandable heap
</span><span style=color:#abb0b6;font-style:italic>//   ...
</span><span style=color:#abb0b6;font-style:italic>//   TRAPFRAME (p->trapframe, used by the trampoline)
</span><span style=color:#abb0b6;font-style:italic>//   TRAMPOLINE (the same page as in the kernel)
</span><span style=color:#fa6e32>#define </span><span style=color:#399ee6>TRAPFRAME </span><span>(TRAMPOLINE </span><span style=color:#ed9366>-</span><span> PGSIZE)
</span></code></pre><h3 id=tiao-guo-bu-fen-jian-cha><a aria-label="Anchor link for: tiao-guo-bu-fen-jian-cha" class=zola-anchor href=#tiao-guo-bu-fen-jian-cha>跳过部分检查</a></h3><p>因为现在不是以前的传统分配了，所以有一些检查会导致我们失败。<br> 因为以前的检查是默认大部分用户的虚拟地址是可以直接映射到物理地址的。<br> 所以我们得跳过一些检查了，这是较为简单的方法。<br> <code>vm.c/uvmunmap</code><pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span style=color:#fa6e32>for</span><span>(a </span><span style=color:#ed9366>=</span><span> va</span><span style=color:#61676ccc>;</span><span> a </span><span style=color:#ed9366><</span><span> va </span><span style=color:#ed9366>+</span><span> npages</span><span style=color:#ed9366>*</span><span>PGSIZE</span><span style=color:#61676ccc>;</span><span> a </span><span style=color:#ed9366>+=</span><span> PGSIZE){
</span><span>  </span><span style=color:#fa6e32>if</span><span>((pte </span><span style=color:#ed9366>= </span><span style=color:#f29718>walk</span><span>(pagetable</span><span style=color:#61676ccc>,</span><span> a</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>0</span><span>)) </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>0</span><span>) </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#abb0b6;font-style:italic>//  panic("uvmunmap: walk");
</span><span>  </span><span style=color:#fa6e32>if</span><span>((</span><span style=color:#ed9366>*</span><span>pte </span><span style=color:#ed9366>&</span><span> PTE_V) </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>0</span><span>) </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#abb0b6;font-style:italic>//  panic("uvmunmap: not mapped");
</span></code></pre><p><code>vm.c/uvmcopy</code><pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span style=color:#fa6e32>for</span><span>(i </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>;</span><span> i </span><span style=color:#ed9366><</span><span> sz</span><span style=color:#61676ccc>;</span><span> i </span><span style=color:#ed9366>+=</span><span> PGSIZE){
</span><span>  </span><span style=color:#fa6e32>if</span><span>((pte </span><span style=color:#ed9366>= </span><span style=color:#f29718>walk</span><span>(old</span><span style=color:#61676ccc>,</span><span> i</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>0</span><span>)) </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>0</span><span>) </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#abb0b6;font-style:italic>//  panic("uvmcopy: pte should exist");
</span><span>  </span><span style=color:#fa6e32>if</span><span>((</span><span style=color:#ed9366>*</span><span>pte </span><span style=color:#ed9366>&</span><span> PTE_V) </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>0</span><span>) </span><span style=color:#fa6e32>continue</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#abb0b6;font-style:italic>//  panic("uvmcopy: page not present");
</span></code></pre><p>现在你输入<code>echo hi</code>时，应该会看到系统输出<code>hi</code>。<h2 id=lazytests-and-usertests-moderate><a aria-label="Anchor link for: lazytests-and-usertests-moderate" class=zola-anchor href=#lazytests-and-usertests-moderate>lazytests and usertests (moderate)</a></h2><p>这个小作业做的我血压有点高呀，因为一直出了一些奇怪的问题，不过我现在已经整理好了，然后我可能会针对性的说一下这些问题，读者们如果遇到了问题也可以看看。<br> ～(　TロT)σ<h3 id=ti-shi-1><a aria-label="Anchor link for: ti-shi-1" class=zola-anchor href=#ti-shi-1>提示</a></h3><p>这个LAB有两个测试，分别是<code>usertests</code>和<code>lazytests</code>。<br> 不过官方也有给一些提示：<ul><li>处理<code>sbrk(-n)</code>的情况，<code>-n</code>的意思是释放n个字节。<li>当系统调用如<code>read()/write()</code>等函数时，可能会有预期之外的报错，修复它。<br> 注：比如我们给进程分配了<code>0x65535</code>的内存，然后进程要<code>write()</code> <code>0x50000</code>，那么我们就应该让他可以写入，只要其处于我们的允许范围内，但并不是无视地址的有效性</ul><h3 id=xi-tong-diao-yong-diao-zheng><a aria-label="Anchor link for: xi-tong-diao-yong-diao-zheng" class=zola-anchor href=#xi-tong-diao-yong-diao-zheng>系统调用调整</a></h3><p>一开始我弄的是<code>write()</code> <code>read()</code> <code>pipe()</code>这三个函数，之后我想优化，就弄<code>copyin()</code>，然后我又发现基本所有<code>copyx()</code>的函数都会调用<code>walkaddr()</code>，然后我就去折腾那函数了，结果就陷入了只有报错的世界。前前后后改了很多次<code>lazyalloc()</code>和<code>walkaddr()</code>。<br> ヽ(*。>Д<)o゜<p>不过呢，我现在弄好了，读者们直接复制粘接就完事了！<br> (๑•̀ㅂ•́)و✧<pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span>uint64
</span><span style=color:#f29718>walkaddr</span><span>(pagetable_t </span><span style=color:#ff8f40>pagetable</span><span style=color:#61676ccc>,</span><span> uint64 </span><span style=color:#ff8f40>va</span><span>)
</span><span>{
</span><span>  pte_t </span><span style=color:#ed9366>*</span><span>pte</span><span style=color:#61676ccc>;
</span><span>  uint64 pa</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#fa6e32>if</span><span>(va </span><span style=color:#ed9366>>=</span><span> MAXVA)
</span><span>    </span><span style=color:#fa6e32>return </span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>;
</span><span>
</span><span>  pte </span><span style=color:#ed9366>= </span><span style=color:#f29718>walk</span><span>(pagetable</span><span style=color:#61676ccc>,</span><span> va</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>0</span><span>)</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>if</span><span>(pte </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>0</span><span style=color:#ed9366>||</span><span>(</span><span style=color:#ed9366>*</span><span>pte </span><span style=color:#ed9366>&</span><span> PTE_V) </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>0</span><span>){
</span><span>    pa </span><span style=color:#ed9366>= </span><span style=color:#f29718>lazyalloc</span><span>(va</span><span style=color:#61676ccc>, </span><span style=color:#f29718>myproc</span><span>())</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>if</span><span>(pa </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>0</span><span>)
</span><span>      </span><span style=color:#fa6e32>return </span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>return</span><span> pa</span><span style=color:#61676ccc>;
</span><span>  }
</span><span>  </span><span style=color:#fa6e32>if</span><span>((</span><span style=color:#ed9366>*</span><span>pte </span><span style=color:#ed9366>&</span><span> PTE_U) </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>0</span><span>)
</span><span>    </span><span style=color:#fa6e32>return </span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>;
</span><span>
</span><span>  pa </span><span style=color:#ed9366>= </span><span style=color:#f29718>PTE2PA</span><span>(</span><span style=color:#ed9366>*</span><span>pte)</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>return</span><span> pa</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h2 id=wan-jie-sa-hua><a aria-label="Anchor link for: wan-jie-sa-hua" class=zola-anchor href=#wan-jie-sa-hua>完结撒花</a></h2><p>好，这下读者们应该就已经完成了，没完成的话...就陷入只有报错的世界吧，之后会变强的！<br> ||ヽ(<em>￣▽￣</em>)ノミ|Ю<p>最后编辑时间：2025/6/23</section></article></main><div class=giscus></div><script async crossorigin issue-term=pathname repo=YOUR_NAME/YOUR_REPO src=https://utteranc.es/client.js theme=github-light></script></div>