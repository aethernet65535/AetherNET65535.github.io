<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://aethernet65535.github.io name=base><title>
            
                XV6-2020 LAB8-LOCK
            
        </title><meta content="XV6-2020 LAB8-LOCK" property=og:title><meta content="This is an example description" property=og:description><meta content="This is an example description" name=description><link href=/icon/favicon.png rel=icon type=image/png><link href=https://aethernet65535.github.io/fonts.css rel=stylesheet><script src=https://aethernet65535.github.io/js/codeblock.js></script><script src=https://aethernet65535.github.io/js/toc.js></script><script src=https://aethernet65535.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link href=https://aethernet65535.github.io/atom.xml rel=alternate title=aethernet-blog type=application/atom+xml><link href=https://aethernet65535.github.io/theme/light.css rel=stylesheet><link href=https://aethernet65535.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://aethernet65535.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://aethernet65535.github.io/main.css media=screen rel=stylesheet><script src="https://aethernet65535.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://aethernet65535.github.io>aethernet-blog</a><div class=socials><a class=social href=https://twitter.com/not_matthias rel=me> <img alt=twitter src=https://aethernet65535.github.io/icons/social/twitter.svg> </a><a class=social href=https://github.com/not-matthias/ rel=me> <img alt=github src=https://aethernet65535.github.io/icons/social/github.svg> </a></div></div><nav><a href=https://aethernet65535.github.io/posts style=margin-left:.25em>/posts</a><a href=https://aethernet65535.github.io/projects style=margin-left:.25em>/projects</a><a href=https://aethernet65535.github.io/about style=margin-left:.25em>/about</a><a href=https://aethernet65535.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://aethernet65535.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://aethernet65535.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://aethernet65535.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>XV6-2020 LAB8-LOCK<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2025-07-06</time> :: 2816 Words <span class=tags-label>:: Tags:</span><span class=tags> <a class=post-tag href=https://aethernet65535.github.io/tags/xv6/>xv6</a> </span></div></div><div class=toc-container><h1 class=toc-title>Table of Contents</h1><ul class=toc-list><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab8-lock/#qian-yan>前言</a><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab8-lock/#memory-allocator-moderate>memory allocator (moderate)</a> <ul><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab8-lock/#wen-ti>问题</a><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab8-lock/#gong-zuo>工作</a><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab8-lock/#ti-shi>提示</a><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab8-lock/#shi-xian>实现</a></li><ul><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab8-lock/#zhong-duan-wei-shen-me-zhong-duan>中断 - 为什么中断？</a></ul></ul><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab8-lock/#buffer-cache-hard>buffer cache (hard)</a> <ul><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab8-lock/#wen-ti-1>问题</a></li><ul><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab8-lock/#ti-shi-1>提示</a></ul><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab8-lock/#jie-jue-fang-an>解决方案</a></li><ul><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab8-lock/#jie-gou-ti-xiu-gai>结构体修改</a><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab8-lock/#ha-xi>哈希</a><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab8-lock/#lrusuan-fa>LRU算法</a><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab8-lock/#brelsede-jian-hua>brelse的简化</a><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab8-lock/#bpin-bunpinde-diao-zheng>bpin/bunpin的调整</a></ul><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab8-lock/#qi-ta-wen-ti>其他问题</a></ul><li><a href=https://aethernet65535.github.io/posts/xv6-2020-lab8-lock/#wan-jie-sa-hua-ps>完结撒花 ψ(._. )></a></ul></div><section class=body><h1 id=qian-yan><a aria-label="Anchor link for: qian-yan" class=zola-anchor href=#qian-yan>前言</a></h1><p>这个LAB...第一个和第二个的难度差距有点大，第一个挺简单，第二个难的离谱（；´д｀）ゞ<p>这个LAB主要是让我们学习到了锁与性能的关系，降低锁的粒度，以此获得更好的性能。<br> 学到的东西也不算少，可以说这LAB和我们上一个LAB的关系还挺大的，都挺好玩的，不过不这个难度确实大不少呢。<br> 简单点来说的话，就是增加程序的并行性，使其的串行性更低，以此获得更好的多核/多线程（这LAB倒是没多线程）性能，虽然现在的CPU单核也很强（我记得苹果的SOC单核超级强），但是多核性能也是可以大大增加使用体验的，相信读者们使用pthread.h时也能很明显的感觉到。<p>这个LAB还有一部分是为下一个LAB（FILE SYSTEM）做热身，我目前还没怎么读，估计明天就会开始读了，不然我压根理解不了呢我觉得。<h1 id=memory-allocator-moderate><a aria-label="Anchor link for: memory-allocator-moderate" class=zola-anchor href=#memory-allocator-moderate>memory allocator (moderate)</a></h1><p>第一个要改的是<code>kalloc.c</code>，这个相对简单，可以说和上一个LAB的某个小作业差不多。<h2 id=wen-ti><a aria-label="Anchor link for: wen-ti" class=zola-anchor href=#wen-ti>问题</a></h2><p>首先我们先来看看“为什么要改”： 现在<code>kalloc()</code>和<code>kfree()</code>有一些问题，就是在多核情况下，会有锁竞争问题，倒不是会影响结果，只是会大幅影响性能。<br> 就是同时只能有一个CPU调用这些函数，我们需要改一下，让这些函数可以同时被多个CPU调用和运行。<h2 id=gong-zuo><a aria-label="Anchor link for: gong-zuo" class=zola-anchor href=#gong-zuo>工作</a></h2><p>我们的工作是要让每个CPU都有自己的freelist，并且在自己的freelist为空时，窃取其他CPU的空闲页。<br> 自然的，锁的数量也得增加，官方有个规定：锁的名字必须以“kmem”开头。<br> 只要<code>kalloctest</code>能完美通过，那就是通过此测试！(｡･∀･)ﾉﾞ<h2 id=ti-shi><a aria-label="Anchor link for: ti-shi" class=zola-anchor href=#ti-shi>提示</a></h2><p>官方倒是有给些提示，我总结了一些较为重要的提示：<ul><li>关于<strong>CPU</strong>有多少个的问题，其实用<code>kernel/param.h</code>的<strong>NCPU</strong>就好了，不用太在意XV6上有多少CPU<li>让<code>freerange()</code>把所有空闲页分配给正在运行的CPU（博主猜测大概率是<strong>CPU 0</strong>，不过这种技术细节先不用太在意）<li>你可以使用<code>pop_off()</code>和<code>push_off()</code>来控制中断的<strong>开关</strong><li><code>cpuid()</code>会返回当前CPU核心编号<li>可以试试<code>snprintf()</code>来对每个锁命名，不过要每个都叫<strong>kmem</strong>也不是不行</ul><h2 id=shi-xian><a aria-label="Anchor link for: shi-xian" class=zola-anchor href=#shi-xian>实现</a></h2><p>首先，我们要先升级一下freelist，从本来的全局版升级为多核独立版。<br> 锁也要对应的增加一下，然后别忘了给锁命名。<pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span style=color:#fa6e32>#define </span><span style=color:#399ee6>LOCKLEN </span><span style=color:#ff8f40>6 </span><span style=color:#abb0b6;font-style:italic>// 锁名长度限制
</span><span>
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>run </span><span>{
</span><span>  </span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>run</span><span> *next</span><span style=color:#61676ccc>;
</span><span>}</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>struct </span><span>{
</span><span>  </span><span style=color:#fa6e32>struct</span><span> spinlock lock</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>char</span><span> lock_name[LOCKLEN]</span><span style=color:#61676ccc>; 
</span><span>  </span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>run</span><span> *freelist</span><span style=color:#61676ccc>;
</span><span>} kmem[NCPU]</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>void
</span><span style=color:#f29718>kinit</span><span>()
</span><span>{
</span><span>  </span><span style=color:#fa6e32>for</span><span>(</span><span style=color:#fa6e32>int</span><span> i </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>;</span><span> i </span><span style=color:#ed9366>&lt;</span><span> NCPU</span><span style=color:#61676ccc>;</span><span> i</span><span style=color:#ed9366>++</span><span>){ </span><span style=color:#abb0b6;font-style:italic>// 循环锁的初始化
</span><span>    </span><span style=color:#f07171>snprintf</span><span>(kmem[i]</span><span style=color:#ed9366>.</span><span>lock_name</span><span style=color:#61676ccc>,</span><span> LOCKLEN</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"kmem </span><span style=color:#ff8f40>%d</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,</span><span> i)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f29718>initlock</span><span>(</span><span style=color:#ed9366>&</span><span>kmem[i]</span><span style=color:#ed9366>.</span><span>lock</span><span style=color:#61676ccc>,</span><span> kmem[i]</span><span style=color:#ed9366>.</span><span>lock_name)</span><span style=color:#61676ccc>;
</span><span>  }
</span><span>  </span><span style=color:#f29718>freerange</span><span>(end</span><span style=color:#61676ccc>, </span><span>(</span><span style=color:#fa6e32>void</span><span style=color:#ed9366>*</span><span>)PHYSTOP)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>这个小作业最难的就是这里的，因为我们要在原版的基础上加上一个窃取机制。<br> 要注意的是，我们得关闭中断，以确保我们获得的CPUID在执行时是正确的。<br> 然后我们还得把freelist改为对应的CPU核心编号。<pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span style=color:#fa6e32>void </span><span style=color:#ed9366>*
</span><span style=color:#f29718>kalloc</span><span>(</span><span style=color:#fa6e32>void</span><span>)
</span><span>{
</span><span>  </span><span style=color:#fa6e32>struct</span><span> run </span><span style=color:#ed9366>*</span><span>r</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#f29718>push_off</span><span>()</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// 关闭中断
</span><span>  </span><span style=color:#fa6e32>int</span><span> cpu </span><span style=color:#ed9366>= </span><span style=color:#f29718>cpuid</span><span>()</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#f29718>acquire</span><span>(</span><span style=color:#ed9366>&</span><span>kmem[cpu]</span><span style=color:#ed9366>.</span><span>lock)</span><span style=color:#61676ccc>;
</span><span>  r </span><span style=color:#ed9366>=</span><span> kmem[cpu]</span><span style=color:#ed9366>.</span><span>freelist</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>if</span><span>(r){
</span><span>    kmem[cpu]</span><span style=color:#ed9366>.</span><span>freelist </span><span style=color:#ed9366>=</span><span> r</span><span style=color:#ed9366>-></span><span>next</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f29718>release</span><span>(</span><span style=color:#ed9366>&</span><span>kmem[cpu]</span><span style=color:#ed9366>.</span><span>lock)</span><span style=color:#61676ccc>;
</span><span>  }</span><span style=color:#fa6e32>else</span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 本地没空闲页也得释放，避免死锁
</span><span>    </span><span style=color:#f29718>release</span><span>(</span><span style=color:#ed9366>&</span><span>kmem[cpu]</span><span style=color:#ed9366>.</span><span>lock)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 窃取空闲页（遍历法）
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 从其他CPU的FREELIST
</span><span>    </span><span style=color:#fa6e32>for</span><span>(</span><span style=color:#fa6e32>int</span><span> nextid </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>;</span><span> nextid </span><span style=color:#ed9366>&lt;</span><span> NCPU</span><span style=color:#61676ccc>;</span><span> nextid</span><span style=color:#ed9366>++</span><span>){
</span><span>      </span><span style=color:#fa6e32>if</span><span>(cpu </span><span style=color:#ed9366>!=</span><span> nextid){
</span><span>        </span><span style=color:#f29718>acquire</span><span>(</span><span style=color:#ed9366>&</span><span>kmem[nextid]</span><span style=color:#ed9366>.</span><span>lock)</span><span style=color:#61676ccc>;
</span><span>        r </span><span style=color:#ed9366>=</span><span> kmem[nextid]</span><span style=color:#ed9366>.</span><span>freelist</span><span style=color:#61676ccc>;
</span><span>
</span><span>        </span><span style=color:#fa6e32>if</span><span>(r){
</span><span>          kmem[nextid]</span><span style=color:#ed9366>.</span><span>freelist </span><span style=color:#ed9366>=</span><span> r</span><span style=color:#ed9366>-></span><span>next</span><span style=color:#61676ccc>;
</span><span>          </span><span style=color:#f29718>release</span><span>(</span><span style=color:#ed9366>&</span><span>kmem[nextid]</span><span style=color:#ed9366>.</span><span>lock)</span><span style=color:#61676ccc>;
</span><span>          </span><span style=color:#fa6e32>break</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>
</span><span>        </span><span style=color:#f29718>release</span><span>(</span><span style=color:#ed9366>&</span><span>kmem[nextid]</span><span style=color:#ed9366>.</span><span>lock)</span><span style=color:#61676ccc>;
</span><span>      }
</span><span>    }
</span><span>  }
</span><span>  </span><span style=color:#f29718>pop_off</span><span>()</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// 开启（也有可能不开启，具体去看源代码）中断
</span><span>
</span><span>  </span><span style=color:#fa6e32>if</span><span>(r)
</span><span>    </span><span style=color:#f07171>memset</span><span>((</span><span style=color:#fa6e32>char</span><span style=color:#ed9366>*</span><span>)r</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>5</span><span style=color:#61676ccc>,</span><span> PGSIZE)</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// fill with junk
</span><span>  </span><span style=color:#fa6e32>return </span><span>(</span><span style=color:#fa6e32>void</span><span style=color:#ed9366>*</span><span>)r</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>这个的话相对简单，只要把释放的空闲页插到对应CPU的链表头就好了，这玩意的不严谨性应该给窃取机制的使用次数降低了不少呢（＞人＜；）。<pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span style=color:#fa6e32>void
</span><span style=color:#f29718>kfree</span><span>(</span><span style=color:#fa6e32>void </span><span style=color:#ed9366>*</span><span style=color:#ff8f40>pa</span><span>)
</span><span>{
</span><span>  </span><span style=color:#fa6e32>struct</span><span> run </span><span style=color:#ed9366>*</span><span>r</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#fa6e32>if</span><span>(((uint64)pa </span><span style=color:#ed9366>%</span><span> PGSIZE) </span><span style=color:#ed9366>!= </span><span style=color:#ff8f40>0 </span><span style=color:#ed9366>|| </span><span>(</span><span style=color:#fa6e32>char</span><span style=color:#ed9366>*</span><span>)pa </span><span style=color:#ed9366>&lt;</span><span> end </span><span style=color:#ed9366>|| </span><span>(uint64)pa </span><span style=color:#ed9366>>=</span><span> PHYSTOP)
</span><span>    </span><span style=color:#f29718>panic</span><span>(</span><span style=color:#86b300>"kfree"</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#abb0b6;font-style:italic>// Fill with junk to catch dangling refs.
</span><span>  </span><span style=color:#f07171>memset</span><span>(pa</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>,</span><span> PGSIZE)</span><span style=color:#61676ccc>;
</span><span>
</span><span>  r </span><span style=color:#ed9366>= </span><span>(</span><span style=color:#fa6e32>struct</span><span> run</span><span style=color:#ed9366>*</span><span>)pa</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#f29718>push_off</span><span>()</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>int</span><span> cpu </span><span style=color:#ed9366>= </span><span style=color:#f29718>cpuid</span><span>()</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#f29718>acquire</span><span>(</span><span style=color:#ed9366>&</span><span>kmem[cpu]</span><span style=color:#ed9366>.</span><span>lock)</span><span style=color:#61676ccc>;
</span><span>  r</span><span style=color:#ed9366>-></span><span>next </span><span style=color:#ed9366>=</span><span> kmem[cpu]</span><span style=color:#ed9366>.</span><span>freelist</span><span style=color:#61676ccc>;
</span><span>  kmem[cpu]</span><span style=color:#ed9366>.</span><span>freelist </span><span style=color:#ed9366>=</span><span> r</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#f29718>release</span><span>(</span><span style=color:#ed9366>&</span><span>kmem[cpu]</span><span style=color:#ed9366>.</span><span>lock)</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#f29718>pop_off</span><span>()</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><h3 id=zhong-duan-wei-shen-me-zhong-duan><a aria-label="Anchor link for: zhong-duan-wei-shen-me-zhong-duan" class=zola-anchor href=#zhong-duan-wei-shen-me-zhong-duan>中断 - 为什么中断？</a></h3><p>中断到开启中断之间的这一个中间过程，好像是会让中间的这段代码不会被其他CPU执行，也就是说只会被当前CPU独占的代码，其他CPU在这一段时间内不可运行（中断后应该就可以了），可能听起来有点复杂，但是意思差不多就是：<blockquote><p>中断后，之后的代码就是能由一个CPU运行了。</blockquote><h4 id=wei-shen-me-bu-shi-intr-on-off><a aria-label="Anchor link for: wei-shen-me-bu-shi-intr-on-off" class=zola-anchor href=#wei-shen-me-bu-shi-intr-on-off>为什么不是intr_on()/off()</a></h4><p>这个...有点难说，主要是因为有时候我们并不希望马上结束中断，内核代码也有不少地方是用pop/pop_off()代替的。我们使用的这种中断开关是有一种比较特殊的东西的，是类似计数器（不是PC计数器之类的，就是count计数而已，叫做noff，每个CPU不共享/独有的），它会记录我们调用了多少次开启中断，多少次关闭中断，只有0的时候才会真正开启中断。<h1 id=buffer-cache-hard><a aria-label="Anchor link for: buffer-cache-hard" class=zola-anchor href=#buffer-cache-hard>buffer cache (hard)</a></h1><p>这个确实不简单，也比上一个难，具体难是在这里：<br> 在第一个小作业，我们要做的只是分配页，只要是freelist里的基本上都没问题。<br> 但是buffer cache的话，读者可以暂时把它理解为一个文件（真正可能是一部分文件，但是这里就把它理解为一整个文件就行了）。系统总不可能随便拿一个文件分给用户，肯定是要拿用户想要的那个文件给用户呀，所以不能简单的用分开CPU的方式来解决锁竞争问题。<h2 id=wen-ti-1><a aria-label="Anchor link for: wen-ti-1" class=zola-anchor href=#wen-ti-1>问题</a></h2><p>和上一个的差不多，就是xv6只用了一个锁来保护所有buffer cache。<blockquote><p>之后我可能会用“（内存上的）文件”来帮简称，易于理解，但是真正肯定不是这种名字。</blockquote><p>这样，CPU foo要读取“甲”文件，而CPU bar要读取“乙”文件。<br> 照xv6的方法，在CPU foo读取成功之前，CPU bar压根不可能读取到，但是我们解决后就“可能”可以了。<h3 id=ti-shi-1><a aria-label="Anchor link for: ti-shi-1" class=zola-anchor href=#ti-shi-1>提示</a></h3><ul><li>可以使用哈希表来降低锁的粒度。<li>哈希表数组长度可以选择质数或2的幂次方，以降低哈希冲突的可能性，或加速查找运算。<li>不再使用bcache.head。</ul><blockquote><p>你可能会好奇“那要怎么做LRU遍历呢？”，其实答案很简单，现在的是怎么样的？最后面的就是最少使用的？嗯...要这样说也没错啦，但是这样的话就会导致<code>brelse()</code>变得有些复杂呢。所以xv6给我想了一个更好的解决方法，使用ticks，就是看谁的ticks最小，那它就是最少用的，这样就能很好的避免复杂化<code>brelse()</code>了（虽然会导致<code>bget()</code>变得复杂就是了｡⁠:ﾟ⁠(⁠;⁠´⁠∩⁠`;⁠)ﾟ⁠:⁠｡）</blockquote><ul><li>可以使用全局锁<code>bcache.head</code>，但是仅限调试用，成品不能使用该全局锁。</ul><h2 id=jie-jue-fang-an><a aria-label="Anchor link for: jie-jue-fang-an" class=zola-anchor href=#jie-jue-fang-an>解决方案</a></h2><h3 id=jie-gou-ti-xiu-gai><a aria-label="Anchor link for: jie-gou-ti-xiu-gai" class=zola-anchor href=#jie-gou-ti-xiu-gai>结构体修改</a></h3><p>首先，我们要先给缓存的结构体，添加一个可以对比各个缓存最后运行时间的字段。<pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span style=color:#fa6e32>struct </span><span style=color:#399ee6>buf </span><span>{
</span><span>  </span><span style=color:#fa6e32>int</span><span> valid</span><span style=color:#61676ccc>;   </span><span style=color:#abb0b6;font-style:italic>// has data been read from disk?
</span><span>  </span><span style=color:#fa6e32>int</span><span> disk</span><span style=color:#61676ccc>;    </span><span style=color:#abb0b6;font-style:italic>// does disk "own" buf?
</span><span>  </span><span style=color:#55b4d4;font-style:italic>uint</span><span> dev</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#55b4d4;font-style:italic>uint</span><span> blockno</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>struct</span><span> sleeplock lock</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#55b4d4;font-style:italic>uint</span><span> refcnt</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>buf</span><span> *prev</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// LRU cache list
</span><span>  </span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>buf</span><span> *next</span><span style=color:#61676ccc>;
</span><span>  uchar data[BSIZE]</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#55b4d4;font-style:italic>uint</span><span> ticks</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// 添加这个
</span><span>}</span><span style=color:#61676ccc>;
</span></code></pre><h3 id=ha-xi><a aria-label="Anchor link for: ha-xi" class=zola-anchor href=#ha-xi>哈希</a></h3><p>先定义一下我们要多少个哈希桶，我选的16，因为是2的幂次方。<br> 13、17之类的也是个不错的选择，由于是质数，所以可以降低哈希冲突的概率。<br> 定义在哪的话...在<code>bio.c</code>或<code>param.h</code>，甚至是其他奇怪的地方，基本都是可以的：<pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span style=color:#fa6e32>#define </span><span style=color:#399ee6>NBUC </span><span style=color:#ff8f40>16
</span></code></pre><p>现在，我们要把原本的数据结构改为哈希表，因为这样就能降低锁的力度，进而降低竞争的激烈性。 用不到的字段删了就行，这样用了就会在编译时报错，编译时报错会更好：<pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span style=color:#fa6e32>struct </span><span>{
</span><span>  
</span><span>  </span><span style=color:#abb0b6;font-style:italic>// 在这LAB用不到这些字段了
</span><span>  </span><span style=color:#abb0b6;font-style:italic>/*  
</span><span style=color:#abb0b6;font-style:italic>  struct buf head;
</span><span style=color:#abb0b6;font-style:italic>  struct spinlock lock;
</span><span style=color:#abb0b6;font-style:italic>  */
</span><span>
</span><span>  </span><span style=color:#fa6e32>struct</span><span> buf buf[NBUF]</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#abb0b6;font-style:italic>// 哈希表
</span><span>  </span><span style=color:#fa6e32>struct</span><span> buf buc[NBUC]</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>struct</span><span> spinlock buc_lock[NBUC]</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#abb0b6;font-style:italic>// 新全局列表
</span><span>  </span><span style=color:#fa6e32>struct</span><span> spinlock glb_lock[NBUC]</span><span style=color:#61676ccc>;
</span><span>} bcache</span><span style=color:#61676ccc>;
</span></code></pre><h4 id=ha-xi-yun-suan><a aria-label="Anchor link for: ha-xi-yun-suan" class=zola-anchor href=#ha-xi-yun-suan>哈希运算</a></h4><p>关于哈希的索引运算，有两种方法，取决于读者们选择了多少哈希桶数量。<p>如果是2的幂次方如4、8、16之类的，可以使用与运算。<pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span style=color:#fa6e32>#define </span><span style=color:#f29718>HASHI</span><span>(</span><span style=color:#ff8f40>noblock</span><span>) (noblock </span><span style=color:#ed9366>& </span><span>(NBUC </span><span style=color:#ed9366>- </span><span style=color:#ff8f40>1</span><span>)) 
</span></code></pre><p>如果是非2的幂次方，那直接取模就完啦！<pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span style=color:#fa6e32>#define </span><span style=color:#f29718>HASHI</span><span>(</span><span style=color:#ff8f40>noblock</span><span>) (noblock </span><span style=color:#ed9366>%</span><span> NBUC)
</span></code></pre><h4 id=chu-shi-hua><a aria-label="Anchor link for: chu-shi-hua" class=zola-anchor href=#chu-shi-hua>初始化</a></h4><p><code>binit()</code>我们得稍微改一下，我们先看看原本的：<pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span style=color:#fa6e32>void
</span><span style=color:#f29718>binit</span><span>(</span><span style=color:#fa6e32>void</span><span>)
</span><span>{
</span><span>  </span><span style=color:#fa6e32>struct</span><span> buf </span><span style=color:#ed9366>*</span><span>b</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#f29718>initlock</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>lock</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"bcache"</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#abb0b6;font-style:italic>// Create linked list of buffers
</span><span>  bcache</span><span style=color:#ed9366>.</span><span>head</span><span style=color:#ed9366>.</span><span>prev </span><span style=color:#ed9366>= &</span><span>bcache</span><span style=color:#ed9366>.</span><span>head</span><span style=color:#61676ccc>;
</span><span>  bcache</span><span style=color:#ed9366>.</span><span>head</span><span style=color:#ed9366>.</span><span>next </span><span style=color:#ed9366>= &</span><span>bcache</span><span style=color:#ed9366>.</span><span>head</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>for</span><span>(b </span><span style=color:#ed9366>=</span><span> bcache</span><span style=color:#ed9366>.</span><span>buf</span><span style=color:#61676ccc>;</span><span> b </span><span style=color:#ed9366>&lt;</span><span> bcache</span><span style=color:#ed9366>.</span><span>buf</span><span style=color:#ed9366>+</span><span>NBUF</span><span style=color:#61676ccc>;</span><span> b</span><span style=color:#ed9366>++</span><span>){
</span><span>    b</span><span style=color:#ed9366>-></span><span>next </span><span style=color:#ed9366>=</span><span> bcache</span><span style=color:#ed9366>.</span><span>head</span><span style=color:#ed9366>.</span><span>next</span><span style=color:#61676ccc>;
</span><span>    b</span><span style=color:#ed9366>-></span><span>prev </span><span style=color:#ed9366>= &</span><span>bcache</span><span style=color:#ed9366>.</span><span>head</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f29718>initsleeplock</span><span>(</span><span style=color:#ed9366>&</span><span>b</span><span style=color:#ed9366>-></span><span>lock</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"buffer"</span><span>)</span><span style=color:#61676ccc>;
</span><span>    bcache</span><span style=color:#ed9366>.</span><span>head</span><span style=color:#ed9366>.</span><span>next</span><span style=color:#ed9366>-></span><span>prev </span><span style=color:#ed9366>=</span><span> b</span><span style=color:#61676ccc>;
</span><span>    bcache</span><span style=color:#ed9366>.</span><span>head</span><span style=color:#ed9366>.</span><span>next </span><span style=color:#ed9366>=</span><span> b</span><span style=color:#61676ccc>;
</span><span>  }
</span><span>}
</span></code></pre><p>看代码能发现，只创建了一个锁，也是全局锁。<p>那我们就照葫芦画瓢，修一下：<pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span style=color:#fa6e32>void
</span><span style=color:#f29718>binit</span><span>(</span><span style=color:#fa6e32>void</span><span>)
</span><span>{
</span><span>  </span><span style=color:#fa6e32>struct</span><span> buf </span><span style=color:#ed9366>*</span><span>b</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>int</span><span> i</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#fa6e32>for</span><span>(i </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>;</span><span> i </span><span style=color:#ed9366>&lt;</span><span> NBUC</span><span style=color:#61676ccc>;</span><span> i</span><span style=color:#ed9366>++</span><span>){
</span><span>    </span><span style=color:#f29718>initlock</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>buc_lock[i]</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"bcache.buc"</span><span>)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#f29718>initlock</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>glb_lock[i]</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"bcache.glb"</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    bcache</span><span style=color:#ed9366>.</span><span>buc[i]</span><span style=color:#ed9366>.</span><span>next </span><span style=color:#ed9366>= &</span><span>bcache</span><span style=color:#ed9366>.</span><span>buc[i]</span><span style=color:#61676ccc>;
</span><span>    bcache</span><span style=color:#ed9366>.</span><span>buc[i]</span><span style=color:#ed9366>.</span><span>prev </span><span style=color:#ed9366>= &</span><span>bcache</span><span style=color:#ed9366>.</span><span>buc[i]</span><span style=color:#61676ccc>;
</span><span>  }
</span><span>
</span><span>  </span><span style=color:#abb0b6;font-style:italic>// 初始化哈希表
</span><span>  </span><span style=color:#abb0b6;font-style:italic>// 头插入法
</span><span>  </span><span style=color:#fa6e32>for</span><span>(b </span><span style=color:#ed9366>=</span><span> bcache</span><span style=color:#ed9366>.</span><span>buf</span><span style=color:#61676ccc>;</span><span> b </span><span style=color:#ed9366>&lt;</span><span> bcache</span><span style=color:#ed9366>.</span><span>buf</span><span style=color:#ed9366>+</span><span>NBUF</span><span style=color:#61676ccc>;</span><span> b</span><span style=color:#ed9366>++</span><span>){
</span><span>    </span><span style=color:#fa6e32>int</span><span> x </span><span style=color:#ed9366>= </span><span style=color:#f29718>HASHI</span><span>(b</span><span style=color:#ed9366>-></span><span>blockno)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    b</span><span style=color:#ed9366>-></span><span>next </span><span style=color:#ed9366>=</span><span> bcache</span><span style=color:#ed9366>.</span><span>buc[x]</span><span style=color:#ed9366>.</span><span>next</span><span style=color:#61676ccc>;
</span><span>    b</span><span style=color:#ed9366>-></span><span>prev </span><span style=color:#ed9366>= &</span><span>bcache</span><span style=color:#ed9366>.</span><span>buc[x]</span><span style=color:#61676ccc>;
</span><span>
</span><span>    bcache</span><span style=color:#ed9366>.</span><span>buc[x]</span><span style=color:#ed9366>.</span><span>next</span><span style=color:#ed9366>-></span><span>prev </span><span style=color:#ed9366>=</span><span> b</span><span style=color:#61676ccc>;
</span><span>    bcache</span><span style=color:#ed9366>.</span><span>buc[x]</span><span style=color:#ed9366>.</span><span>next </span><span style=color:#ed9366>=</span><span> b</span><span style=color:#61676ccc>;
</span><span>
</span><span>    b</span><span style=color:#ed9366>-></span><span>ticks </span><span style=color:#ed9366>=</span><span> ticks</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#f29718>initsleeplock</span><span>(</span><span style=color:#ed9366>&</span><span>b</span><span style=color:#ed9366>-></span><span>lock</span><span style=color:#61676ccc>, </span><span style=color:#86b300>"buffer"</span><span>)</span><span style=color:#61676ccc>;
</span><span>  }
</span><span>}
</span></code></pre><h3 id=lrusuan-fa><a aria-label="Anchor link for: lrusuan-fa" class=zola-anchor href=#lrusuan-fa>LRU算法</a></h3><p>函数的代码有点长，我先大致说一下这个代码都是做什么的。<br> 大致上的流程就是：<blockquote><ol><li>进入大临界区。<li>查找该数据对应的缓存块是否存在，如果存在直接返回，如果不存在则继续。<li>查找没有被占用且最久没被使用的缓存块，完全找不到就panic，找到了就继续。<li>如果找到的块不在用户想要的哈希桶内，则转移。<li>初始化，并返回给调用方。</ol></blockquote><pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span style=color:#fa6e32>static struct</span><span> buf</span><span style=color:#ed9366>*
</span><span style=color:#f29718>bget</span><span>(</span><span style=color:#55b4d4;font-style:italic>uint </span><span style=color:#ff8f40>dev</span><span style=color:#61676ccc>, </span><span style=color:#55b4d4;font-style:italic>uint </span><span style=color:#ff8f40>blockno</span><span>)
</span><span>{
</span><span>  </span><span style=color:#fa6e32>struct</span><span> buf </span><span style=color:#ed9366>*</span><span>b</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>int</span><span> x </span><span style=color:#ed9366>= </span><span style=color:#f29718>HASHI</span><span>(blockno)</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#abb0b6;font-style:italic>// 从这里开始
</span><span>  </span><span style=color:#f29718>acquire</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>glb_lock[x])</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#abb0b6;font-style:italic>// 要找的块有没有缓存了？
</span><span>  </span><span style=color:#f29718>acquire</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>buc_lock[x])</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>for</span><span>(b </span><span style=color:#ed9366>=</span><span> bcache</span><span style=color:#ed9366>.</span><span>buc[x]</span><span style=color:#ed9366>.</span><span>next</span><span style=color:#61676ccc>;</span><span> b </span><span style=color:#ed9366>!= &</span><span>bcache</span><span style=color:#ed9366>.</span><span>buc[x]</span><span style=color:#61676ccc>;</span><span> b </span><span style=color:#ed9366>=</span><span> b</span><span style=color:#ed9366>-></span><span>next){
</span><span>    </span><span style=color:#fa6e32>if</span><span>(b</span><span style=color:#ed9366>-></span><span>dev </span><span style=color:#ed9366>==</span><span> dev </span><span style=color:#ed9366>&&</span><span> b</span><span style=color:#ed9366>-></span><span>blockno </span><span style=color:#ed9366>==</span><span> blockno){
</span><span>      b</span><span style=color:#ed9366>-></span><span>refcnt</span><span style=color:#ed9366>++</span><span style=color:#61676ccc>;
</span><span>      </span><span style=color:#f29718>release</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>buc_lock[x])</span><span style=color:#61676ccc>;
</span><span>      </span><span style=color:#f29718>release</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>glb_lock[x])</span><span style=color:#61676ccc>;
</span><span>      </span><span style=color:#f29718>acquiresleep</span><span>(</span><span style=color:#ed9366>&</span><span>b</span><span style=color:#ed9366>-></span><span>lock)</span><span style=color:#61676ccc>;
</span><span>      </span><span style=color:#fa6e32>return</span><span> b</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>  }
</span><span>  </span><span style=color:#abb0b6;font-style:italic>// 还没呢
</span><span>  </span><span style=color:#f29718>release</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>buc_lock[x])</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#abb0b6;font-style:italic>// LRU的必要变量初始化
</span><span>  </span><span style=color:#fa6e32>struct</span><span> buf </span><span style=color:#ed9366>*</span><span>minb </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#abb0b6;font-style:italic>// 这里的作用是，mticks = 最大值，非0就是0xFFFF...（就是全是F）
</span><span>  </span><span style=color:#55b4d4;font-style:italic>uint</span><span> mticks </span><span style=color:#ed9366>= ~</span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#abb0b6;font-style:italic>// 遍历所有桶
</span><span>  </span><span style=color:#fa6e32>for</span><span>(</span><span style=color:#fa6e32>int</span><span> i </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>;</span><span> i </span><span style=color:#ed9366>&lt;</span><span> NBUC</span><span style=color:#61676ccc>;</span><span> i</span><span style=color:#ed9366>++</span><span>){
</span><span>    </span><span style=color:#f29718>acquire</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>buc_lock[i])</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>int</span><span> find </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 找到最近用的最少的块
</span><span>    </span><span style=color:#fa6e32>for</span><span>(b </span><span style=color:#ed9366>=</span><span> bcache</span><span style=color:#ed9366>.</span><span>buc[i]</span><span style=color:#ed9366>.</span><span>next</span><span style=color:#61676ccc>;</span><span> b </span><span style=color:#ed9366>!= &</span><span>bcache</span><span style=color:#ed9366>.</span><span>buc[i]</span><span style=color:#61676ccc>;</span><span> b </span><span style=color:#ed9366>=</span><span> b</span><span style=color:#ed9366>-></span><span>next){
</span><span>      </span><span style=color:#fa6e32>if</span><span>(b</span><span style=color:#ed9366>-></span><span>refcnt </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>0 </span><span style=color:#ed9366>&&</span><span> b</span><span style=color:#ed9366>-></span><span>ticks </span><span style=color:#ed9366>&lt;</span><span> mticks){
</span><span>        </span><span style=color:#fa6e32>if</span><span>(minb </span><span style=color:#ed9366>!= </span><span style=color:#ff8f40>0</span><span>){
</span><span>          </span><span style=color:#fa6e32>int</span><span> last </span><span style=color:#ed9366>= </span><span style=color:#f29718>HASHI</span><span>(minb</span><span style=color:#ed9366>-></span><span>blockno)</span><span style=color:#61676ccc>;
</span><span>          </span><span style=color:#fa6e32>if</span><span>(last </span><span style=color:#ed9366>!=</span><span> i)
</span><span>            </span><span style=color:#f29718>release</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>buc_lock[last])</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>        mticks </span><span style=color:#ed9366>=</span><span> b</span><span style=color:#ed9366>-></span><span>ticks</span><span style=color:#61676ccc>;
</span><span>        minb </span><span style=color:#ed9366>=</span><span> b</span><span style=color:#61676ccc>;
</span><span>        find </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>;
</span><span>      }
</span><span>    }
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// 当前桶内没空闲的块
</span><span>    </span><span style=color:#fa6e32>if</span><span>(</span><span style=color:#ed9366>!</span><span>find)
</span><span>      </span><span style=color:#f29718>release</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>buc_lock[i])</span><span style=color:#61676ccc>;
</span><span>  }
</span><span>
</span><span>  </span><span style=color:#abb0b6;font-style:italic>// 完了，完全没有空闲块
</span><span>  </span><span style=color:#fa6e32>if</span><span>(minb </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>0</span><span>)
</span><span>    </span><span style=color:#f29718>panic</span><span>(</span><span style=color:#86b300>"bget: no buffers"</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#fa6e32>int</span><span> minb_x </span><span style=color:#ed9366>= </span><span style=color:#f29718>HASHI</span><span>(minb</span><span style=color:#ed9366>-></span><span>blockno)</span><span style=color:#61676ccc>;
</span><span>
</span><span>  minb</span><span style=color:#ed9366>-></span><span>dev </span><span style=color:#ed9366>=</span><span> dev</span><span style=color:#61676ccc>;
</span><span>  minb</span><span style=color:#ed9366>-></span><span>blockno </span><span style=color:#ed9366>=</span><span> blockno</span><span style=color:#61676ccc>;
</span><span>  minb</span><span style=color:#ed9366>-></span><span>valid </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>;
</span><span>  minb</span><span style=color:#ed9366>-></span><span>refcnt </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#abb0b6;font-style:italic>// 如果找到的空闲块
</span><span>  </span><span style=color:#abb0b6;font-style:italic>// 不在用户想要的桶内
</span><span>  </span><span style=color:#abb0b6;font-style:italic>// 那就移动去调用方想要的桶
</span><span>
</span><span>  </span><span style=color:#abb0b6;font-style:italic>// 这里只是把那个空闲块移出去
</span><span>  </span><span style=color:#fa6e32>if</span><span>(minb_x </span><span style=color:#ed9366>!=</span><span> x){
</span><span>    minb</span><span style=color:#ed9366>-></span><span>prev</span><span style=color:#ed9366>-></span><span>next </span><span style=color:#ed9366>=</span><span> minb</span><span style=color:#ed9366>-></span><span>next</span><span style=color:#61676ccc>;
</span><span>    minb</span><span style=color:#ed9366>-></span><span>next</span><span style=color:#ed9366>-></span><span>prev </span><span style=color:#ed9366>=</span><span> minb</span><span style=color:#ed9366>-></span><span>prev</span><span style=color:#61676ccc>;
</span><span>  }
</span><span>  </span><span style=color:#f29718>release</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>buc_lock[minb_x])</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#abb0b6;font-style:italic>// 这里用的是头插入法
</span><span>  </span><span style=color:#abb0b6;font-style:italic>// 把那个空闲块放进调用方想要的桶
</span><span>  </span><span style=color:#fa6e32>if</span><span>(minb_x </span><span style=color:#ed9366>!=</span><span> x){
</span><span>    </span><span style=color:#f29718>acquire</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>buc_lock[x])</span><span style=color:#61676ccc>;
</span><span>
</span><span>    minb</span><span style=color:#ed9366>-></span><span>next </span><span style=color:#ed9366>=</span><span> bcache</span><span style=color:#ed9366>.</span><span>buc[x]</span><span style=color:#ed9366>.</span><span>next</span><span style=color:#61676ccc>;
</span><span>    minb</span><span style=color:#ed9366>-></span><span>prev </span><span style=color:#ed9366>= &</span><span>bcache</span><span style=color:#ed9366>.</span><span>buc[x]</span><span style=color:#61676ccc>;
</span><span>    bcache</span><span style=color:#ed9366>.</span><span>buc[x]</span><span style=color:#ed9366>.</span><span>next</span><span style=color:#ed9366>-></span><span>prev </span><span style=color:#ed9366>=</span><span> minb</span><span style=color:#61676ccc>;
</span><span>    bcache</span><span style=color:#ed9366>.</span><span>buc[x]</span><span style=color:#ed9366>.</span><span>next </span><span style=color:#ed9366>=</span><span> minb</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#f29718>release</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>buc_lock[x])</span><span style=color:#61676ccc>;
</span><span>  }
</span><span>  
</span><span>  </span><span style=color:#abb0b6;font-style:italic>// 在这里结束
</span><span>  </span><span style=color:#f29718>release</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>glb_lock[x])</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#f29718>acquiresleep</span><span>(</span><span style=color:#ed9366>&</span><span>minb</span><span style=color:#ed9366>-></span><span>lock)</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>return</span><span> minb</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>现在，看完代码的你，可能并不完全理解这函数是干什么的。<br> 这些可能会有助于你理解这段函数：<ul><li><code>bcache.glb_lock[NBUC]</code>是一个<strong>桶级全局锁</strong>，它在<code>bget()</code>的大部分执行过程中被持有。它的主要作用类似我们之前的全局锁，但是之前的全局锁是真的全局，这个是桶级全局。<li><code>bcache.buc_lock[NBUC]</code>是一个<strong>哈希桶链表锁</strong>，它的作用范围更小，在<code>glb_lock</code>保护的大临界区内，当需要对哈希桶内部的链表结构（如遍历、插入节点）进行操作时，就会使用<code>buc_lock</code>来保护链表，避免并发修改导致链表损坏。<li>不过其实这两个锁本质都是一样的，你要直接把这两个锁交换来用都行，你不混着用就好了。<li><code>b->lock</code>是每个缓存块各有的锁，为了保护其数据，<code>bget()</code>在返回缓存块前，会先给该缓存块获取锁。</ul><h3 id=brelsede-jian-hua><a aria-label="Anchor link for: brelsede-jian-hua" class=zola-anchor href=#brelsede-jian-hua>brelse的简化</a></h3><p>我们先看看原本的brelese是干什么的：<pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span style=color:#fa6e32>void
</span><span style=color:#f29718>brelse</span><span>(</span><span style=color:#fa6e32>struct</span><span> buf </span><span style=color:#ed9366>*</span><span style=color:#ff8f40>b</span><span>)
</span><span>{
</span><span>  </span><span style=color:#fa6e32>if</span><span>(</span><span style=color:#ed9366>!</span><span style=color:#f29718>holdingsleep</span><span>(</span><span style=color:#ed9366>&</span><span>b</span><span style=color:#ed9366>-></span><span>lock))
</span><span>    </span><span style=color:#f29718>panic</span><span>(</span><span style=color:#86b300>"brelse"</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#f29718>releasesleep</span><span>(</span><span style=color:#ed9366>&</span><span>b</span><span style=color:#ed9366>-></span><span>lock)</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#f29718>acquire</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>lock)</span><span style=color:#61676ccc>;
</span><span>  b</span><span style=color:#ed9366>-></span><span>refcnt</span><span style=color:#ed9366>--</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>if </span><span>(b</span><span style=color:#ed9366>-></span><span>refcnt </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>0</span><span>) {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// no one is waiting for it.
</span><span>    b</span><span style=color:#ed9366>-></span><span>next</span><span style=color:#ed9366>-></span><span>prev </span><span style=color:#ed9366>=</span><span> b</span><span style=color:#ed9366>-></span><span>prev</span><span style=color:#61676ccc>;
</span><span>    b</span><span style=color:#ed9366>-></span><span>prev</span><span style=color:#ed9366>-></span><span>next </span><span style=color:#ed9366>=</span><span> b</span><span style=color:#ed9366>-></span><span>next</span><span style=color:#61676ccc>;
</span><span>    b</span><span style=color:#ed9366>-></span><span>next </span><span style=color:#ed9366>=</span><span> bcache</span><span style=color:#ed9366>.</span><span>head</span><span style=color:#ed9366>.</span><span>next</span><span style=color:#61676ccc>;
</span><span>    b</span><span style=color:#ed9366>-></span><span>prev </span><span style=color:#ed9366>= &</span><span>bcache</span><span style=color:#ed9366>.</span><span>head</span><span style=color:#61676ccc>;
</span><span>    bcache</span><span style=color:#ed9366>.</span><span>head</span><span style=color:#ed9366>.</span><span>next</span><span style=color:#ed9366>-></span><span>prev </span><span style=color:#ed9366>=</span><span> b</span><span style=color:#61676ccc>;
</span><span>    bcache</span><span style=color:#ed9366>.</span><span>head</span><span style=color:#ed9366>.</span><span>next </span><span style=color:#ed9366>=</span><span> b</span><span style=color:#61676ccc>;
</span><span>  }
</span><span>  
</span><span>  </span><span style=color:#f29718>release</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>lock)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>作用就是：<ol><li>确认持有该块的睡眠锁：</ol><ul><li>没有就panic<li>持有就释放掉锁</ul><ol start=2><li>获取全局锁<li>给引用次数-1<li>如果不再使用该块了：</ol><ul><li>移动到块链表头部</ul><ol start=5><li>不管有没有执行<code>4</code>，都会释放锁</ol><p>这个函数对我们来说已经没有用了，或者说它的逻辑错误，原因为以下几点：<ul><li>我们已经不使用<code>bcache.lock</code>作为全局锁了<li>我们已经不使用<code>bcache.head</code>作为头节点了<li>我们已经不使用单链表进行块管理了</ul><p>所以我们得稍微改改：<pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span style=color:#fa6e32>void
</span><span style=color:#f29718>brelse</span><span>(</span><span style=color:#fa6e32>struct</span><span> buf </span><span style=color:#ed9366>*</span><span style=color:#ff8f40>b</span><span>)
</span><span>{
</span><span>  </span><span style=color:#fa6e32>if</span><span>(</span><span style=color:#ed9366>!</span><span style=color:#f29718>holdingsleep</span><span>(</span><span style=color:#ed9366>&</span><span>b</span><span style=color:#ed9366>-></span><span>lock))
</span><span>    </span><span style=color:#f29718>panic</span><span>(</span><span style=color:#86b300>"brelse"</span><span>)</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#f29718>releasesleep</span><span>(</span><span style=color:#ed9366>&</span><span>b</span><span style=color:#ed9366>-></span><span>lock)</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#fa6e32>int</span><span> x </span><span style=color:#ed9366>= </span><span style=color:#f29718>HASHI</span><span>(b</span><span style=color:#ed9366>-></span><span>blockno)</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#f29718>acquire</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>buc_lock[x])</span><span style=color:#61676ccc>;
</span><span>  b</span><span style=color:#ed9366>-></span><span>refcnt</span><span style=color:#ed9366>--</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#fa6e32>if </span><span>(b</span><span style=color:#ed9366>-></span><span>refcnt </span><span style=color:#ed9366>== </span><span style=color:#ff8f40>0</span><span>)
</span><span>    b</span><span style=color:#ed9366>-></span><span>ticks </span><span style=color:#ed9366>=</span><span> ticks</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#f29718>release</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>buc_lock[x])</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>我们用了更简单的方法，就是改<code>ticks</code>而已， 毕竟我们的LRU就是遍历找<code>ticks</code>而已嘛， <code>brelse()</code>的一部分可以说是为<code>bget()</code>的LRU算法服务的。<h3 id=bpin-bunpinde-diao-zheng><a aria-label="Anchor link for: bpin-bunpinde-diao-zheng" class=zola-anchor href=#bpin-bunpinde-diao-zheng>bpin/bunpin的调整</a></h3><p>这个就没什么简化了，只是调整而已，一样的，先上原本的：<pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span style=color:#fa6e32>void
</span><span style=color:#f29718>bpin</span><span>(</span><span style=color:#fa6e32>struct</span><span> buf </span><span style=color:#ed9366>*</span><span style=color:#ff8f40>b</span><span>) {
</span><span>  </span><span style=color:#f29718>acquire</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>lock)</span><span style=color:#61676ccc>;
</span><span>  b</span><span style=color:#ed9366>-></span><span>refcnt</span><span style=color:#ed9366>++</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#f29718>release</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>lock)</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#fa6e32>void
</span><span style=color:#f29718>bunpin</span><span>(</span><span style=color:#fa6e32>struct</span><span> buf </span><span style=color:#ed9366>*</span><span style=color:#ff8f40>b</span><span>) {
</span><span>  </span><span style=color:#f29718>acquire</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>lock)</span><span style=color:#61676ccc>;
</span><span>  b</span><span style=color:#ed9366>-></span><span>refcnt</span><span style=color:#ed9366>--</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#f29718>release</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>lock)</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>和刚刚的差不多，就只是因为<code>bcache.lock</code>现在不能用了而已， 所以我们要改成<code>bcache.buc_lock[NBUC]</code>的版本呢。<pre class=language-C data-lang=C style=color:#61676c;background-color:#fafafa><code class=language-C data-lang=C><span style=color:#fa6e32>void
</span><span style=color:#f29718>bpin</span><span>(</span><span style=color:#fa6e32>struct</span><span> buf </span><span style=color:#ed9366>*</span><span style=color:#ff8f40>b</span><span>) {
</span><span>  </span><span style=color:#fa6e32>int</span><span> x </span><span style=color:#ed9366>= </span><span style=color:#f29718>HASHI</span><span>(b</span><span style=color:#ed9366>-></span><span>blockno)</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#f29718>acquire</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>buc_lock[x])</span><span style=color:#61676ccc>;
</span><span>  b</span><span style=color:#ed9366>-></span><span>refcnt</span><span style=color:#ed9366>++</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#f29718>release</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>buc_lock[x])</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#fa6e32>void
</span><span style=color:#f29718>bunpin</span><span>(</span><span style=color:#fa6e32>struct</span><span> buf </span><span style=color:#ed9366>*</span><span style=color:#ff8f40>b</span><span>) {
</span><span>  </span><span style=color:#fa6e32>int</span><span> x </span><span style=color:#ed9366>= </span><span style=color:#f29718>HASHI</span><span>(b</span><span style=color:#ed9366>-></span><span>blockno)</span><span style=color:#61676ccc>;
</span><span>
</span><span>  </span><span style=color:#f29718>acquire</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>buc_lock[x])</span><span style=color:#61676ccc>;
</span><span>  b</span><span style=color:#ed9366>-></span><span>refcnt</span><span style=color:#ed9366>--</span><span style=color:#61676ccc>;
</span><span>  </span><span style=color:#f29718>release</span><span>(</span><span style=color:#ed9366>&</span><span>bcache</span><span style=color:#ed9366>.</span><span>buc_lock[x])</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>这个就不过多解释了，基本没什么理解难度。<h2 id=qi-ta-wen-ti><a aria-label="Anchor link for: qi-ta-wen-ti" class=zola-anchor href=#qi-ta-wen-ti>其他问题</a></h2><p>Q：ticks会不会溢出，多久？<br> A：会，不过<strong>有点</strong>慢，大概要13年左右。<blockquote><p>我稍微解释下，xv6的1ticks是0.1秒，也就是说，一秒有10ticks。所以要这样算：<br> (2^32 - 1) ÷ 10 ≈ 429,496,729s<br> 429,496,729s ÷ 60 ≈ 119,306h<br> 119,306 ÷ 24 ≈ 4971d<br> 4971d ÷ 356 ≈ 13y<br> 要是从32位进化到64位，更不敢想了吧，天文数字了。</blockquote><h1 id=wan-jie-sa-hua-ps><a aria-label="Anchor link for: wan-jie-sa-hua-ps" class=zola-anchor href=#wan-jie-sa-hua-ps>完结撒花 ψ(._. )></a></h1><p>这个其实还挺有难度的，死锁之类的，还有一些并发问题，很难，不过也很好玩，因为并发并行这些东西是在很多领域的适用的。虽然我听说好像有很多高级语言都有自带多线程，甚至不需要程序员干预。但是，读者们会来学XV6，我想多多少少还是希望了解计算机的。<p>总之，加油吧！屏幕前的所有读者！<p>仓库链接：https://github.com/aethernet65535/DOCKER-XV6_2020/tree/lock<p>最后编辑时间：2025/7/21</section></article></main><div class=giscus></div><script async crossorigin issue-term=pathname repo=YOUR_NAME/YOUR_REPO src=https://utteranc.es/client.js theme=github-light></script></div>