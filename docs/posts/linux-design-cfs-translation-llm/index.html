<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://aethernet65535.github.io name=base><title>
            
                DESIGN OF CFS - DEEPSEEK TRANSLATION
            
        </title><meta content="DESIGN OF CFS - DEEPSEEK TRANSLATION" property=og:title><meta content="This is an example description" property=og:description><meta content="This is an example description" name=description><link href=/icon/favicon.png rel=icon type=image/png><link href=https://aethernet65535.github.io/fonts.css rel=stylesheet><script src=https://aethernet65535.github.io/js/codeblock.js></script><script src=https://aethernet65535.github.io/js/toc.js></script><script src=https://aethernet65535.github.io/js/note.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link href=https://aethernet65535.github.io/atom.xml rel=alternate title=aethernet-blog type=application/atom+xml><link href=https://aethernet65535.github.io/theme/light.css rel=stylesheet><link href=https://aethernet65535.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://aethernet65535.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://aethernet65535.github.io/main.css media=screen rel=stylesheet><script src="https://aethernet65535.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><div class=content><header><div class=main><a href=https://aethernet65535.github.io>aethernet-blog</a><div class=socials><a class=social href=https://twitter.com/not_matthias rel=me> <img alt=twitter src=https://aethernet65535.github.io/icons/social/twitter.svg> </a><a class=social href=https://github.com/not-matthias/ rel=me> <img alt=github src=https://aethernet65535.github.io/icons/social/github.svg> </a></div></div><nav><a href=https://aethernet65535.github.io/posts style=margin-left:.25em>/posts</a><a href=https://aethernet65535.github.io/projects style=margin-left:.25em>/projects</a><a href=https://aethernet65535.github.io/about style=margin-left:.25em>/about</a><a href=https://aethernet65535.github.io/tags style=margin-left:.25em>/tags</a><button title="$SHORTCUT to open search" class=search-button id=search-button><img alt=Search class=search-icon src=https://aethernet65535.github.io/icons/search.svg></button><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><div id=modal-content><h1 class=page-header id=modalTitle>Search</h1><div id=searchBar><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search... role=combobox spellcheck=false><button title="Clear search" class=clear-button id=clear-search><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></button></div><div id=results-container><div id=results-info><span id=zero_results style=display:none>No results</span><span id=one_result style=display:none>1 result</span><span id=many_results style=display:none>$NUMBER results</span></div><div id=results role=listbox></div></div></div></div><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://aethernet65535.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://aethernet65535.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>DESIGN OF CFS - DEEPSEEK TRANSLATION<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2025-08-13</time> :: 2529 Words <span class=tags-label>:: Tags:</span><span class=tags> <a class=post-tag href=https://aethernet65535.github.io/tags/linux/>linux</a> </span></div></div><div class=toc-container><h1 class=toc-title>Table of Contents</h1><ul class=toc-list><li><a href=https://aethernet65535.github.io/posts/linux-design-cfs-translation-llm/#fan-yi-ban>翻译版</a> <ul><li><a href=https://aethernet65535.github.io/posts/linux-design-cfs-translation-llm/#gai-shu>概述</a><li><a href=https://aethernet65535.github.io/posts/linux-design-cfs-translation-llm/#guan-jian-shi-xian-xi-jie>关键实现细节</a><li><a href=https://aethernet65535.github.io/posts/linux-design-cfs-translation-llm/#hong-hei-shu-ji-zhi>红黑树机制</a><li><a href=https://aethernet65535.github.io/posts/linux-design-cfs-translation-llm/#he-xin-te-xing>核心特性</a><li><a href=https://aethernet65535.github.io/posts/linux-design-cfs-translation-llm/#diao-du-ce-lue>调度策略</a><li><a href=https://aethernet65535.github.io/posts/linux-design-cfs-translation-llm/#diao-du-lei-jia-gou>调度类架构</a><li><a href=https://aethernet65535.github.io/posts/linux-design-cfs-translation-llm/#zu-diao-du-kuo-zhan>组调度扩展</a></ul><li><a href=https://aethernet65535.github.io/posts/linux-design-cfs-translation-llm/#yuan-ban-dui-bi-yong>原版（对比用）</a> <ul><li><a href=https://aethernet65535.github.io/posts/linux-design-cfs-translation-llm/#overview>OVERVIEW</a><li><a href=https://aethernet65535.github.io/posts/linux-design-cfs-translation-llm/#few-implementation-details>FEW IMPLEMENTATION DETAILS</a><li><a href=https://aethernet65535.github.io/posts/linux-design-cfs-translation-llm/#the-rbtree>THE RBTREE</a><li><a href=https://aethernet65535.github.io/posts/linux-design-cfs-translation-llm/#some-features-of-cfs>SOME FEATURES OF CFS</a><li><a href=https://aethernet65535.github.io/posts/linux-design-cfs-translation-llm/#scheduling-policies>Scheduling policies</a><li><a href=https://aethernet65535.github.io/posts/linux-design-cfs-translation-llm/#scheduling-classes>SCHEDULING CLASSES</a><li><a href=https://aethernet65535.github.io/posts/linux-design-cfs-translation-llm/#group-scheduler-extensions-to-cfs>GROUP SCHEDULER EXTENSIONS TO CFS</a></ul></ul></div><section class=body><p>由DEEPSEEK V3翻译：<h1 id=fan-yi-ban><a aria-label="Anchor link for: fan-yi-ban" class=zola-anchor href=#fan-yi-ban>翻译版</a></h1><h2 id=gai-shu><a aria-label="Anchor link for: gai-shu" class=zola-anchor href=#gai-shu>概述</a></h2><p>========<p>CFS（Completely Fair Scheduler，完全公平调度器）由Ingo Molnar开发，自Linux 2.6.23版本并入内核，最初用于替代原调度器中SCHED_OTHER类型的交互式代码。当前CFS正逐步为EEVDF调度器让路，相关文档见Documentation/scheduler/sched-eevdf.rst。<p>CFS的设计理念可用一句话概括：它试图在真实硬件上模拟"理想的多任务处理器"的行为。所谓"理想多任务处理器"是指一种（现实中不存在的）能并行精确分配计算资源的CPU——当运行n个任务时，每个任务始终能获得1/n的物理算力。例如：两个任务运行时，每个任务能获得50%的实际并行算力。<p>由于真实硬件一次只能运行单个任务，CFS引入了"虚拟运行时（virtual runtime）"概念。任务的虚拟运行时表示其在理想多任务CPU上获得的下一个时间片起始时刻。实际实现中，虚拟运行时是任务实际运行时间经任务总数标准化后的值。<h2 id=guan-jian-shi-xian-xi-jie><a aria-label="Anchor link for: guan-jian-shi-xian-xi-jie" class=zola-anchor href=#guan-jian-shi-xian-xi-jie>关键实现细节</a></h2><p>================<p>CFS通过p->se.vruntime（纳秒单位）来追踪每个任务的虚拟运行时，借此精确计量任务应获得的CPU时间。<p>理想硬件上所有任务的p->se.vruntime值应始终相同，意味着所有任务能同步执行且永远不会偏离理想的CPU时间分配。CFS的调度策略基于该值实现：总是选择p->se.vruntime最小的任务（即累计执行时间最短的任务），尽可能接近理想多任务处理器的分配效果。<p>其他设计要素如nice级别、多处理器支持等均围绕这一核心思想展开。<h2 id=hong-hei-shu-ji-zhi><a aria-label="Anchor link for: hong-hei-shu-ji-zhi" class=zola-anchor href=#hong-hei-shu-ji-zhi>红黑树机制</a></h2><p>==============<p>CFS采用革命性设计：使用时间排序的红黑树构建任务执行时间线，摒弃传统运行队列结构，从而消除旧调度器（包括RSDL/SD）的"数组切换"问题。<p>关键数据结构包括：<ul><li>rq->cfs.min_vruntime：单调递增值，记录运行队列中最小的vruntime<li>rq->cfs.load：运行队列中所有任务的权重总和</ul><p>调度器总是选择红黑树最左端任务执行。随着系统运行，已执行任务会被逐渐移到红黑树右侧，确保每个任务都能在确定时间内获得CPU资源。<p>具体流程：任务运行一段时间后，其实际CPU占用时间会被累加到p->se.vruntime。当该值超过当前最左端任务的vruntime（考虑调度粒度避免频繁切换），则触发任务切换。<h2 id=he-xin-te-xing><a aria-label="Anchor link for: he-xin-te-xing" class=zola-anchor href=#he-xin-te-xing>核心特性</a></h2><p>============<ul><li>纳秒级精度计时，不依赖jiffies或HZ<li>唯一可调参数：/sys/kernel/debug/sched/base_slice_ns（用于调整桌面/服务器场景的延迟特性）<li>天然免疫传统调度器的攻击向量（如fiftyp.c等测试用例）<li>更严格的nice级别和SCHED_BATCH隔离<li>简化的SMP负载均衡实现</ul><h2 id=diao-du-ce-lue><a aria-label="Anchor link for: diao-du-ce-lue" class=zola-anchor href=#diao-du-ce-lue>调度策略</a></h2><p>============<p>实现三种策略：<ul><li>SCHED_NORMAL（原SCHED_OTHER）：常规任务<li>SCHED_BATCH：适合批处理作业，减少抢占<li>SCHED_IDLE：优先级低于nice 19，但非真正的空闲调度</ul><p>实时策略（SCHED_FIFO/_RR）由sched/rt.c实现，符合POSIX标准。<h2 id=diao-du-lei-jia-gou><a aria-label="Anchor link for: diao-du-lei-jia-gou" class=zola-anchor href=#diao-du-lei-jia-gou>调度类架构</a></h2><p>==============<p>采用模块化的调度类层次结构，核心模块包括：<ul><li>sched/fair.c：实现CFS<li>sched/rt.c：简化实现的实时调度器（使用100个运行队列）</ul><p>通过sched_class结构体实现关键操作钩子：<ul><li>enqueue_task/dequeue_task：任务进出可运行状态<li>yield_task：任务主动让出CPU<li>pick_next_task：选择下一个运行任务<li>task_tick：驱动抢占的时间滴答处理</ul><h2 id=zu-diao-du-kuo-zhan><a aria-label="Anchor link for: zu-diao-du-kuo-zhan" class=zola-anchor href=#zu-diao-du-kuo-zhan>组调度扩展</a></h2><p>==============<p>通过以下配置支持任务分组调度：<ul><li>CONFIG_CGROUP_SCHED：基础组调度支持<li>CONFIG_RT_GROUP_SCHED：实时任务组<li>CONFIG_FAIR_GROUP_SCHED：CFS任务组</ul><p>使用示例：<pre class=language-bash data-lang=bash style=color:#61676c;background-color:#fafafa><code class=language-bash data-lang=bash><span style=color:#abb0b6;font-style:italic># 创建多媒体/浏览器任务组并分配CPU权重
</span><span style=color:#f07171>echo</span><span> 2048 </span><span style=color:#ed9366>></span><span> multimedia/cpu.shares
</span><span style=color:#f07171>echo</span><span> 1024 </span><span style=color:#ed9366>></span><span> browser/cpu.shares
</span><span style=color:#abb0b6;font-style:italic># 将firefox加入浏览器组
</span><span style=color:#f07171>echo </span><span style=color:#ed9366>&lt;</span><span>pid</span><span style=color:#ed9366>> ></span><span> browser/tasks
</span></code></pre><h1 id=yuan-ban-dui-bi-yong><a aria-label="Anchor link for: yuan-ban-dui-bi-yong" class=zola-anchor href=#yuan-ban-dui-bi-yong>原版（对比用）</a></h1><h2 id=overview><a aria-label="Anchor link for: overview" class=zola-anchor href=#overview>OVERVIEW</a></h2><p>============<p>CFS stands for "Completely Fair Scheduler," and is the "desktop" process scheduler implemented by Ingo Molnar and merged in Linux 2.6.23. When originally merged, it was the replacement for the previous vanilla scheduler's SCHED_OTHER interactivity code. Nowadays, CFS is making room for EEVDF, for which documentation can be found in Documentation/scheduler/sched-eevdf.rst.<p>80% of CFS's design can be summed up in a single sentence: CFS basically models an "ideal, precise multi-tasking CPU" on real hardware.<p>"Ideal multi-tasking CPU" is a (non-existent :-)) CPU that has 100% physical power and which can run each task at precise equal speed, in parallel, each at 1/nr_running speed. For example: if there are 2 tasks running, then it runs each at 50% physical power --- i.e., actually in parallel.<p>On real hardware, we can run only a single task at once, so we have to introduce the concept of "virtual runtime." The virtual runtime of a task specifies when its next timeslice would start execution on the ideal multi-tasking CPU described above. In practice, the virtual runtime of a task is its actual runtime normalized to the total number of running tasks.<h2 id=few-implementation-details><a aria-label="Anchor link for: few-implementation-details" class=zola-anchor href=#few-implementation-details>FEW IMPLEMENTATION DETAILS</a></h2><p>==============================<p>In CFS the virtual runtime is expressed and tracked via the per-task p->se.vruntime (nanosec-unit) value. This way, it's possible to accurately timestamp and measure the "expected CPU time" a task should have gotten.<p>Small detail: on "ideal" hardware, at any time all tasks would have the same p->se.vruntime value --- i.e., tasks would execute simultaneously and no task would ever get "out of balance" from the "ideal" share of CPU time.<p>CFS's task picking logic is based on this p->se.vruntime value and it is thus very simple: it always tries to run the task with the smallest p->se.vruntime value (i.e., the task which executed least so far). CFS always tries to split up CPU time between runnable tasks as close to "ideal multitasking hardware" as possible.<p>Most of the rest of CFS's design just falls out of this really simple concept, with a few add-on embellishments like nice levels, multiprocessing and various algorithm variants to recognize sleepers.<h2 id=the-rbtree><a aria-label="Anchor link for: the-rbtree" class=zola-anchor href=#the-rbtree>THE RBTREE</a></h2><p>==============<p>CFS's design is quite radical: it does not use the old data structures for the runqueues, but it uses a time-ordered rbtree to build a "timeline" of future task execution, and thus has no "array switch" artifacts (by which both the previous vanilla scheduler and RSDL/SD are affected).<p>CFS also maintains the rq->cfs.min_vruntime value, which is a monotonic increasing value tracking the smallest vruntime among all tasks in the runqueue. The total amount of work done by the system is tracked using min_vruntime; that value is used to place newly activated entities on the left side of the tree as much as possible.<p>The total number of running tasks in the runqueue is accounted through the rq->cfs.load value, which is the sum of the weights of the tasks queued on the runqueue.<p>CFS maintains a time-ordered rbtree, where all runnable tasks are sorted by the p->se.vruntime key. CFS picks the "leftmost" task from this tree and sticks to it. As the system progresses forwards, the executed tasks are put into the tree more and more to the right --- slowly but surely giving a chance for every task to become the "leftmost task" and thus get on the CPU within a deterministic amount of time.<p>Summing up, CFS works like this: it runs a task a bit, and when the task schedules (or a scheduler tick happens) the task's CPU usage is "accounted for": the (small) time it just spent using the physical CPU is added to p->se.vruntime. Once p->se.vruntime gets high enough so that another task becomes the "leftmost task" of the time-ordered rbtree it maintains (plus a small amount of "granularity" distance relative to the leftmost task so that we do not over-schedule tasks and trash the cache), then the new leftmost task is picked and the current task is preempted.<h2 id=some-features-of-cfs><a aria-label="Anchor link for: some-features-of-cfs" class=zola-anchor href=#some-features-of-cfs>SOME FEATURES OF CFS</a></h2><p>========================<p>CFS uses nanosecond granularity accounting and does not rely on any jiffies or other HZ detail. Thus the CFS scheduler has no notion of "timeslices" in the way the previous scheduler had, and has no heuristics whatsoever. There is only one central tunable:<p>/sys/kernel/debug/sched/base_slice_ns<p>which can be used to tune the scheduler from "desktop" (i.e., low latencies) to "server" (i.e., good batching) workloads. It defaults to a setting suitable for desktop workloads. SCHED_BATCH is handled by the CFS scheduler module too.<p>In case CONFIG_HZ results in base_slice_ns &lt; TICK_NSEC, the value of base_slice_ns will have little to no impact on the workloads.<p>Due to its design, the CFS scheduler is not prone to any of the "attacks" that exist today against the heuristics of the stock scheduler: fiftyp.c, thud.c, chew.c, ring-test.c, massive_intr.c all work fine and do not impact interactivity and produce the expected behavior.<p>The CFS scheduler has a much stronger handling of nice levels and SCHED_BATCH than the previous vanilla scheduler: both types of workloads are isolated much more aggressively.<p>SMP load-balancing has been reworked/sanitized: the runqueue-walking assumptions are gone from the load-balancing code now, and iterators of the scheduling modules are used. The balancing code got quite a bit simpler as a result.<h2 id=scheduling-policies><a aria-label="Anchor link for: scheduling-policies" class=zola-anchor href=#scheduling-policies>Scheduling policies</a></h2><p>======================<p>CFS implements three scheduling policies:<ul><li><p>SCHED_NORMAL (traditionally called SCHED_OTHER): The scheduling policy that is used for regular tasks.</p><li><p>SCHED_BATCH: Does not preempt nearly as often as regular tasks would, thereby allowing tasks to run longer and make better use of caches but at the cost of interactivity. This is well suited for batch jobs.</p><li><p>SCHED_IDLE: This is even weaker than nice 19, but its not a true idle timer scheduler in order to avoid to get into priority inversion problems which would deadlock the machine.</p></ul><p>SCHED_FIFO/_RR are implemented in sched/rt.c and are as specified by POSIX.<p>The command chrt from util-linux-ng 2.13.1.1 can set all of these except SCHED_IDLE.<h2 id=scheduling-classes><a aria-label="Anchor link for: scheduling-classes" class=zola-anchor href=#scheduling-classes>SCHEDULING CLASSES</a></h2><p>======================<p>The new CFS scheduler has been designed in such a way to introduce "Scheduling Classes," an extensible hierarchy of scheduler modules. These modules encapsulate scheduling policy details and are handled by the scheduler core without the core code assuming too much about them.<p>sched/fair.c implements the CFS scheduler described above.<p>sched/rt.c implements SCHED_FIFO and SCHED_RR semantics, in a simpler way than the previous vanilla scheduler did. It uses 100 runqueues (for all 100 RT priority levels, instead of 140 in the previous scheduler) and it needs no expired array.<p>Scheduling classes are implemented through the sched_class structure, which contains hooks to functions that must be called whenever an interesting event occurs.<p>This is the (partial) list of the hooks:<ul><li><p>enqueue_task(...)</p> <p>Called when a task enters a runnable state. It puts the scheduling entity (task) into the red-black tree and increments the nr_running variable.</p><li><p>dequeue_task(...)</p> <p>When a task is no longer runnable, this function is called to keep the corresponding scheduling entity out of the red-black tree. It decrements the nr_running variable.</p><li><p>yield_task(...)</p> <p>This function is basically just a dequeue followed by an enqueue, unless the compat_yield sysctl is turned on; in that case, it places the scheduling entity at the right-most end of the red-black tree.</p><li><p>wakeup_preempt(...)</p> <p>This function checks if a task that entered the runnable state should preempt the currently running task.</p><li><p>pick_next_task(...)</p> <p>This function chooses the most appropriate task eligible to run next.</p><li><p>set_next_task(...)</p> <p>This function is called when a task changes its scheduling class, changes its task group or is scheduled.</p><li><p>task_tick(...)</p> <p>This function is mostly called from time tick functions; it might lead to process switch. This drives the running preemption.</p></ul><h2 id=group-scheduler-extensions-to-cfs><a aria-label="Anchor link for: group-scheduler-extensions-to-cfs" class=zola-anchor href=#group-scheduler-extensions-to-cfs>GROUP SCHEDULER EXTENSIONS TO CFS</a></h2><p>=====================================<p>Normally, the scheduler operates on individual tasks and strives to provide fair CPU time to each task. Sometimes, it may be desirable to group tasks and provide fair CPU time to each such task group. For example, it may be desirable to first provide fair CPU time to each user on the system and then to each task belonging to a user.<p>CONFIG_CGROUP_SCHED strives to achieve exactly that. It lets tasks to be grouped and divides CPU time fairly among such groups.<p>CONFIG_RT_GROUP_SCHED permits to group real-time (i.e., SCHED_FIFO and SCHED_RR) tasks.<p>CONFIG_FAIR_GROUP_SCHED permits to group CFS (i.e., SCHED_NORMAL and SCHED_BATCH) tasks.<p>These options need CONFIG_CGROUPS to be defined, and let the administrator create arbitrary groups of tasks, using the "cgroup" pseudo filesystem. See Documentation/admin-guide/cgroup-v1/cgroups.rst for more information about this filesystem.<p>When CONFIG_FAIR_GROUP_SCHED is defined, a "cpu.shares" file is created for each group created using the pseudo filesystem. See example steps below to create task groups and modify their CPU share using the "cgroups" pseudo filesystem::<pre style=color:#61676c;background-color:#fafafa><code><span># mount -t tmpfs cgroup_root /sys/fs/cgroup
</span><span># mkdir /sys/fs/cgroup/cpu
</span><span># mount -t cgroup -ocpu none /sys/fs/cgroup/cpu
</span><span># cd /sys/fs/cgroup/cpu
</span><span>
</span><span># mkdir multimedia	# create "multimedia" group of tasks
</span><span># mkdir browser		# create "browser" group of tasks
</span><span>
</span><span># #Configure the multimedia group to receive twice the CPU bandwidth
</span><span># #that of browser group
</span><span>
</span><span># echo 2048 > multimedia/cpu.shares
</span><span># echo 1024 > browser/cpu.shares
</span><span>
</span><span># firefox &	# Launch firefox and move it to "browser" group
</span><span># echo &lt;firefox_pid> > browser/tasks
</span><span>
</span><span># #Launch gmplayer (or your favourite movie player)
</span><span># echo &lt;movie_player_pid> > multimedia/tasks    </span></code></pre></section></article></main><div class=giscus></div><script async crossorigin issue-term=pathname repo=YOUR_NAME/YOUR_REPO src=https://utteranc.es/client.js theme=github-light></script></div>